# study-for-the-teest

`1. 소프트웨어 생명주기
- 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것
1) 폭포수 모형 : 각 단계를 확실하게 하고 검토하고 승인 과정을 거친 후 다음 단계를 행하는 이론
2) 프로토타입 모형 : 견본품을 만들어 최종 결과물 예측
3) 나선형 모형 : 여러 소프트웨어 개발 과정을 거쳐 점진적으로 개발 [계획수립-위험분석-개발 및 검증-고객평가]
4) 애자일 모형 : 요구사항 변화에 대응하도록 일정한 주기를 반복하면서 개발

2. XP 기법
- 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화 - 의단용존피
1) Pair Programming (짝 프로그래밍): 다른 사람과 함께 프로그래밍을 수행하여 책임을 공동으로 나눔
2) Collective Ownership (공동 코드 소유) : 코드에 대한 권한과 책임을 공등 소유
3) Test-Drive Development (테스트 주도 개발) : 테스트케이스를 먼저 작성, 자동화된 테스팅 도구 사용
4) Continuous Integration (계속적인 통합) : 모듈 단위로 개발한걸 지속적으로 통합

3. 요구사항 분석 [도- 분- 명- 확]
-사용자의 요구사항을 이해하고 문서화하는 활동
1) 자료 흐름도(DFD) 
  -프로세스 : 자료를 변환 (원,사각형)
  -자료흐름 : 자료의 이동 (화살표)
  -자료 저장소 : 자료 저장소 (id:물
  -단말(Terminator) : 시스템과 교신하는 외부 개체

2) 자료 사전(DD)
- 자료 흐름도에 있는 자료를 정의하고 기록한것
- = : 자료 정의
- + : 자료 연결
- () : 자료 생략
- [] : 자료 선택
- {} : 자료 반복
- ** : 자료 설명

4. UML
- 상호간의 의사소통이 원활하게 이루어지도록 표준화한 모델링언어
- 요소 : 사물, 관계, 다이어그램

소프트웨어 재사용 : 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
소프트웨어 재공학 : 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것
CASE : 소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화 시키는 것

수학적 비용 산정 기법
COCOMO 모형 : LOC(원시코드라인 수)를 이용 (보헴)
유형 : 조직형 (5만 라인), 반분리형 (30만 라인 이하), 내장형(30만 라인 이상)
종류 : 기본형, 중간형, 발전형
putnam 모형 : 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상 (푸트넘) - 자동화도구 : SLIM
기능점수(FP) 모형 : 소프트웨어의 기능을 증대시키는 요인별 기능 점수(FP)를 구한 후 비용을 산정하는 기법 (알브레히트)

소프트웨어 개발 표준 : 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준
ISO/IEC 12207 : ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스
CMMI : 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델 
SPICE : 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

데이터베이스: 공동으로 사용될 데이터를 중복을 배제하여 통합, 저장장치에 저장하여 항상 운영
DBMS : 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어 (필수기능 3가지 : 정의,조작,제어)
스키마 : 제약조건에 관한 전반적인 명세를 기술 (3가지 : 외부,개념,내부 스키마)
데이터베이스 설계 : 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장
설계 순서 : 요구사항 분설 ->개논물->구현
개념적 설계 : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
논리적 설계 : 현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료구조로 변환시키는 과정
물리적 설계  논리적 구조로 표현된 데이터를 물리적 구조로 변환

RDBMS : 2차원적인 표를 이요해서 데이터 상호 관계를 정의하는 데이터 베이스
튜플 : 릴레이션을 구성하는 각각의 행
속상 : 데이터베이스를 구성하는 가장 작은 논리적 단위
도메인 : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합
후보키 : 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합 (유일성,최소성 만족)
기본키 : 후보키 중에서 선정된 주 키
대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
슈퍼키 : 속성들의 집합으로 구성된 키
외래키 : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

무결성 : 데이터베이스에 저장된 데이터 값과 현실세계의 실제값이 일치하는 정확성
종류
개체 무결성 : 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다
참조 무결성 : 외래키 값은 Null이거나 기본키 값과 동일 해야함.
도메인 무결성 : 주어진 속성 값이 정의된 도메인에 속한 값이어야함
사용자 정의 무결성 : 사용자가 정의한 제약조건에 만족되어야 한다
NULL 무결성 : 특정 속성 값이 NULL이 될 수 없다
고유 무결성 : 튜플이 갖는 속성값이 서로 달라야 한다
키 무결성 : 하나의 릴레이션에는 적어도 하나의 키 존재
관계 무결성 : 튜플의 삽입 가능 여부 또는 한 ㅇ릴레이션과 다른 릴레이션의 튜플들 사이의 관계대한 적절성 여부 지정

관계대수 : 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어
순수 관계 연산자
Select (시그마) : 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
Project(파이) : 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션 만듬
Join (넥타이) : 공통 속성을 중심으로 두 개의 릴세이션을 하나로 합침
Division(나누기) : R과S 릴레이션에서 S가 가진 속성을 제외
관계해석 : 관계 데이터의 연산을 표현하는 방법

정규화 : 데이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정
반정규화 : 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위

트랙잭션 : 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산
특성 4가지
- 원자성 : 데이터베이스 모두 반영(Commit)되던지 모두 안되던지(Rollback)해야함
- 일관성 : 언제나 일관성있는 상태
- 독립성 : 둘 이상의 트랜잭션이 실행되도 서로 연산에 끼어들 수 없음
- 지속성 : 시스템이 고장나도 영구적으로 반영되야함

CRUD분석 : 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것

뷰 : 하나 이상의 기본 테이블로부터 유도된 가상의 테이블
클러스터 : 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
분산 데이터베이스 : 논리적으로는 하나의 시스템이지만 물리적으로는 네트워크를 통해 연결된 여러개 사이트에 분산된 데이터베이스
분산 데이터베이스 목표 : 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성

객체지향 분석 : 사용자의 요구사항관 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업
객체지향 분석 방법론
- Runbaugh(럼바우) 방법 : 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 
--- 객체 모델링 : 정보 모델리이라고도 하며 객체 다이어그램으로 표시
--- 동적 모델링 : 상태 다이어그램 이용
--- 기능 모델링 : 자료 흐름도(DFD) 이용
- Booch(부치)방법 : 미시적,거시적 개발 프로세스 모두 사용
- Jacobson 방법 : 유스케이스를 강조하여 사용
- Coad와 Yourdon 방법 : E-R다이어그램을 사용
- Wirfs-Brock 방법 : 분석 설계 간의 구분이 없고, 고객 명세서를 평가

객체지향 설계 원칙 : 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 원칙
SOLID : SRP, OCP, LSP, ISP, DIP
단일 책임 원칙 (SRP) : 객체는 단 하나의 책임만 갖는다.
개방-폐쇄 원칙 (OCP) : 기존의 코드를 변겨하지 않고 기능을 추가한다
리스코프 치환 원칙 (LSP) : 자식 클래스는 최소한 부모 클래스의 기능은 수행해야한다.
인터페이스 분리 원칙 (ISP) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거난 영향을 받지 않아야 한다.
의존 역전의 원칙 (DIP) : 의존 관계 성립 시 추사성이 높은 클래스와 의존 관계를 맺어야 한다.

모듈 : 모듈화를 통해 분리된 시스템의 각 기능
모듈의 독립성 : 결합도와 응집도로 측정
결합도 : 모듈 간에 상호 의존하는 정도 , 약할수록 좋다, 아래로갈수록 약함
내용 - 공통 - 외부 - 제어 - 스탬프 - 자료 결합도
응집도 : 모듈의 내부 요소들이 서로 관련되어 있는 정도, 강할수록 좋다, 아래로 갈수록 약함
기능적 - 순차적 - 교화적 - 절차적 - 시간적 - 논리적 - 우연적 응집도
팬인(Fan-In) : 어떤 모듈을 제어하는 모듈의 수
팬아웃(Fan-Out) : 어떤 모듈에 의해 제어되는 모듈의 수
N-S차트 : 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법

공통모듈 : 여러 프로그램에서 공통으로 사용할 수 있는 모듈 (종류 : 정확성, 명확성, 완전성, 일광성, 추적성)
재사용 : 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업
코드 : 자료의 분류,조합,집계,추출을 용이하게 하기 위해 사용하는 기호
코드의 기능 : 식별기능, 분류기능, 배열기능, 표준화기능, 간소화기능
코드의 종류 : 순차 코드 (1,2,3..) 블록코드 (1001~1100 : 총무부), 10진 코드, 그룹 분류 코드, 연상 코드(TV-40), 표의 숫자 코드(120-720-1500 : 두께x폭x길이),합성코드

디자인 패턴 : 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적이 해결 방식 또는 예제 (GOF의 디자인패턴 : 생성패턴,구조패턴,행위패턴)
배치 프로그램 : 여러 작업들을 미리 정해진 일련의 순서에 따라 일관적으로 처리하도록 만든 프로그램
- 대용량 데이터, 자동화, 견고성, 안전성. 성능
배치 스케줄러 : 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
- 스프링 배치, Quartz, Cron

미들웨어 : 운영체제와 응용 프로그램 또는 서버와 클라이언트 사이에서 서비스를 제공하는 소프트웨어
종류 : DB, RPC, MOM, TP-Monitor, ORB, WAS
- DB : 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어
- RPC (원격 프로시저 호출) : 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어
- MOM (메시지 지향 미들웨어) : 비동기형 메시지를 전달하는 미들웨어
- TP-Monitor (트랜잭션 처리 모니터) : 트랜잭션을 처리 및 감시하는 미들웨어
- ORB (객체 요청 브로커) : 코바 표준 스펙을 구현한 객체 지향 미들웨어
- WAS (웹 애플리케이션 서버) : 동적인 콘턴츠를 처리하기 위한 미들웨어

모듈연계 : 내부모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환 (EAI, ESB, 웹 서비스)
EAI : 기업 내 각종 애플리케이션 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션
- Point-to-Point : 가장 기본적, 1:1 연결
- Hub&Spoke : 단일 접점인 허브 시스템을 통해 데이터 전송
- Message Bus : 애플리케이션 사이에 미들웨어를 둠, 대용량 처리 가능
- Hybrid : Hub & Spoke 와 Message bus 혼합 , 데이터 병목 현상을 최소화
ESB : 애플리케이션 간 표준 기반의 인터페이스를 제공하는 솔루션,결합도를 약하게 유지한다.
웹 서비스 : 네트워크 정보를 표준환된 서비스 형태로 만들어 공유하는 기술
- SOAP : HTTP, SMTP 등을 활용하여 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜
- UDDI : WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
- WSDL : 웹 서비스명, 서비스 제공 위치, 프로토콜 등 웹 서비스에 대한 상세 정보를 XML형식으로 구현

인터페이스 구현 검증 : 인터페이스가 정상적으로 문제없이 작동하는지 확인하는것
인터페이스 구현 검증 도구
- xUnit : java,c++,Net 등 다양한 언어를 지원하는 단위 테스트 프레임워크
- STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- NTAF : FitNess + STAF (NHN에서 만듦)
- watir : Ruby를 사용하는 테스트 프레임워크
APM : 애플리케이션의 성능 관리를 위해 다양한 모니터링 기능을 제공하는 도구
- 스카우터 : 애플리케이션 및 OS 자원에 대한 모니터링 기능을 제공하는 오픈소스 APM 소프트웨어
- 제니퍼 : 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지, 전 단계에 걸쳐 성능을 모니터링

사용자 인터페이스 : CLI ,GUI ,NUI(사용자의 말이나 행동으로 조작)
기본 원칙 : 직관성, 유효성, 학습성, 유연성

소프트웨어 품질 관련 표준
ISO/IEC 9126 : 소프트웨어의 품질 특서과 평가를 위한 국제 표준
ISO/IEC 25010 : ISO/IEC 9126에 호환성과 보안성을 강화
ISO/IEC 12119 : 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준
ISO/IEC 14598 : 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준

ISO/IEC 9126 특성
기능성 : 요구사항을 정확하게 만족하는가
신뢰성 : 주어진 시간동안 주어진 기능을 오류 없이 수행했는가
사용성 : 사용자가 정확하게 이해하고 사용하는정도
효율성 : 얼마나 빠르게 처리할 수 있는가
유지보수성 : 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도
이식성 : 다른 환경에서도 얼마나 쉽게 적용할 수 있는지
 
[1] 애플리케이션 테스트

1. 애플리케이션 테스트

-애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차
- 고객의 요구사항을 만족시키는지 확인(Validation) 정확히 수행하는지 검증(Verification)

2. 기본 원리

완벽한 테스트 불가능 : 결함을 줄일순 있지만 결함이 없다고 할 수 없음

파레토의 법칙 : 20%에 해당하는 코드에서 전체 결함의 80%가 발견

살충제 패러독스 : 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않음

테스팅은 정황의존 : 정황(특징,환경,역량 등)에 따라 테스트를 다르게 수행

오류-부재의 궤변 : 결함이 없어도 요구사항을 만족 못하면 품질이 높다고 할 수 없음

기타 : 테스트와 위험은 반비례/테스트의 점진적 확대/테스트의 별도 팀 수행

[2] 애플리케이션 테스트의 분류

1. 프로그램 실행 여부에 따른 테스트

정적 테스트
- 프로그램을 실행하지 않고 명세서나 소스코드를 분석 
- 코디 표준,스타일,복잡도,남은 결함 등을 발견하기 위해 사용함
- 종류 : 워크스루, 인스팩션, 코드 검사

동적 테스트
- 프로그래믈 실행하여 오류를 찾는 테스트
- 소프트웨어 개발의 모든 단계에서 테스트 수행
- 종류 : 블랙박스 테스트, 화이트박스 테스트

2. 테스트 기반에 따른 테스트

명세 기반 테스트 : 동등 분할, 경계 값 분석 등
구조 기반 테스트 : 구문 기반, 결정 기반, 조건 기반 등
경험 기반 테스트 : 에러 추정, 체크 리스트, 탐색적 테스팅

3. 시각에 따른 테스트

검증 테스트 : 개발자의 시각에서 제품 생산 과정을 테스트 (명세대로 완성됐는지)
확인 테스트 : 상요자 시각에서 생산된 제품의 결과를 테스트 (요구사할대로 완성 됐는지)

4. 목적에 따른 테스트

회복/안전/강도/성능/구조/회귀/병행 테스트






[3] 테스트 기법에 따른 애플리케이션 테스트

1. 화이트박스 테스트
- 원시코드의 논리적인 모든 경로를 테스트하여 테스트케이스를 설계
- 모듈안의 작동을 직접 관찰
- 원시 코드(모듈)의 모든 문장을 한 번 이상 실행한다.

2. 화이트박스 테스트 종류

기초 경로 검사  
- 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정 할 수 있게 해주는 테스트기법
- 대표적인 화이트박스 테스트 기법

제어 구조 검사
- 조건검사 : 프로그램 모듈 내에 있는 논리적 조건을 테스트 하는 테스트 케이스 설계 기법
- 루프검사 : 프르그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
- 데이터 흐름 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 설계 기법

3. 화이트박스 테스트의 검증 기준
- 문장 검증 기준 : 소스 코드의 모든 구문이 한 번 이사 수행되도록 테스트 케이스 설계
- 분기 검증 기준 : 소스 코드의 모든 조건문이 한 번 이상 수행되도록 테스트 케이서 설계
- 조건 검증 기준 : 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행되도록 설계
- 분기/조건 기준 : 소스 코드의 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 Ture인 경우와 False인 경후가 한 변 이상 수행되도록 설계

4. 블랙박스 테스트
- 블랙박스 테스트는 소프트웨억 수해할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트
- 사용자의 요구사항 명세를 보면서 테스트
- 주로 구현된 기능을 테스트
- 소프트웨어 인터페이스를 통해 실시

5. 블랙박스 테스트 종류
- 동치 분할 검사(=동등 분할 기법) : 프로그램의 입력조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 
                                              테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인

- 경계값 분석 : 입력조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 
                   입력 조건의 경계값을 테이스케이스로 선정하여 검사하는 기법

- 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효융성이 높은 
                                 테스트 케이스를 선정하여 검사하는 기법

- 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트하는 기법

- 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

[4] 개발 단계에 따를 애플리케이션 테스트

소프트웨어 생명 주기의 V-모델 : 요구사항-분석-설계-구현 V 단위테스트-통합테스트-시스템테스트-인수테스트

1. 단위 테스트
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트
- 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행한다.
- 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행한다.

2. 통합 테스트
- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
- 모듈 간 또는 통합된 컴포넌트 간의 상호 적용 오류를 검사

3. 시스템 테스트
- 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
- 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각 만족하는지 테스트한다.

4. 인수 테스트
- 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법
- 사용자각 직접 테스트한다.
- 6가지 종류로 구분해서 테스트한다.
1) 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부를 확인
2) 운영상의 인수 테스트 : 관리자가 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검등을 확인
3) 계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 확인
4) 규정 인수 테스트 : 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인
5) 알파 테스트 : 사용자가 개발자 앞에서 행하는 테스트, 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인
6) 베타 테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 기법, 실업무를 가지고 사용자가 직접 테스트

[5] 통합 테스트

1. 통합테스트
- 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
-종류 
1) 비점진적 통합 방식 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방식
   - 종류 ) 빅백 통합 테스트 방식
2) 점진적 통합 방식 : 모듈 단위로 단계적으로 통합하면서 테스트하는 방식
   - 종류 ) 하향식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트

2. 하향식 통합 테스트
- 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
- 깊이 우선 통합법이나 넓이 우선 통합법 사용
- 하양식 통합 테스트 절차
1) 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁을로 대체한다
*스텁 : 제어모듈이 호출하는 타 모듈의 기능을 단순희 수행하는 도구로 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
2) 깊이 또는 넓이 우선 등의 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈에 교체된다
3) 모듈이 통합될 댸마다 테스트를 실시한다.
4) 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 실시한다.

3. 상향식 통합 테스트
-하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
-상향식 통합 테스트 절차
1) 하위 모듈들을 클러스터로 결합한다.
*클러스터 : 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹을 의미
2) 상위 모듈에서 데이터의 입,출력을 확인하기 ㅜ이해 더미 모듈인 드라이버를 작성한다.
*테스트 드라이버 : 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 결과를 도출하는 도구
3) 통합된 클러스트 단위로 테스트
4) 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체

4. 혼합식 통합 테스트
-하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합하여 최적의 테스트 지원/샌드위치라고도 한다.

5. 회귀 테스팅
-통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트이다.
[6] 애플리케이션 테스트 프로세스

1. 애플리케이션 테스트 프로세스
-개발된 소프트웨어가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차
1) 테스트 계획 : 프로젝트 계획서, 요구 명세서 등을 기반으로 테스트 목표를 정의하고 태스트대상 및 범위를 결정함
2) 테스트 분석 및 디자인 : 테스트의 목적과 원칙을 검토하고 사용자의 요구사항을 분석함
3) 테스트 케이스 및 시나리오 작성: 테스트 케이스 작성 및 검토하고 시나리오 작성
4) 테스트 수행 : 테스트 환경을 구축한 후 테스트를 수행
5) 테스트 결과 평과 및 리포팅 : 테스트 비교 분석후 결과서 작성
6) 결함 추적 및 관리 : 결함 발생 위치나 종류 등 결함을 추적하고 관리

2. 결함 관리 프로세스
1) 에러 발견 : 에러가 발견되면 테스트 전문가와 프로젝트팀이 논의함
2) 에러 등록 : 발견된 에러를 결함 관리 대장에 등록
3) 에러 분석 : 등록된 에러가 실제 결함 인지 아닌지를 분석
4) 결함 확정 : 실제 결함이면 결함 확정으로 등록함.
5) 결함 할당 : 담당자에게 결함을 할당하고 결함 할당 상태로 성정
6) 결함 조치 : 결함을 수정하고, 수정이 완료되면 결함 조치 상태로 설정
6) 결함 조치 검토 및 승인 : 수정이 완료된 결함에 대해 확인 테스트 수행, 이상이 없으면 결함 조치 완료

[7] 테스트 케이스/ 테스트 시나리오 / 테스트 오라클

1. 테스트 케이스(TC)
- 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대결과 등으로 구성된 테스트 항목에 대한 명세서이다.
- 테스트 케이스를 미리 설계하면 테스트 오류 방지, 테스트 수행에 필요한 인력, 시간 등의 자원 낭비를 줄일 수 있다.

2. 테스트 시나리오
- 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합
- 테스트 케이스를 적용하는 구체적인 절차를 명세
- 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설저되어있다.

3. 테스트 오라클
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법
- 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인 한다.
- 테스트 오라클의 특징
1) 제한된 검증 : 테스트 오라클을 모든 테스트 케이스에 적용할 수 없음
2) 수학적 기법 : 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있음
3) 자동화 가능 : 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음

4. 테스트 오라클의 종류
- 참 오라클 : 모든 테스트 케이스의 입력값에 대해 기대하는 결과를 제공하는 오라클, 발생된 모든 오류 검출 가능
- 샘플링 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용
- 추정 오라클 : 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- 일관성 검사 오라클 : 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

[8] 테스트 자동화 도구

1. 테스트 자동화
- 테스트를 자동화하여 효율적으로 테스트 수행
- 종류 : 정적 분석/테스트 실행/성능 테스트/테스트 통제
1) 정적 분석 도구
- 프로그램을 실행 하지 않고 분석하는 도구
- 소스코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용
2) 테스트 실행 도구
- 스크립트 언어를 사용하여 태스트를 실행하는 도구
- 데이터 주도 접근 방식 : 스프레드시트에 테스트 데이터를 저장하고, 이를 읽어 실행하는 방식
- 키워드 주도 접근 방식 : 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장하여 실행하는 방식
3) 성능 테스트 도구 
- 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구
4) 테스트 통제 도구
- 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구
- 종류 : 형상 관리 도구, 결함 추적/관리 도구 등

2. 테스트 하네스 도구
-테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트 되도록 하는 도구
-테스트 하네스의 구성 요소
1) 테스트 드라이버 : 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구
2) 테스트 스텁 : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용모듈
3) 테스트 슈트 : 테스트 대상 컴포넌트 모듈, 시스템에 사용되는 테스트 케이스의 집합
4) 테스트 케이스 : 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력값, 실행 조건, 기대 결과 등으로 만들어진 명세서
5) 테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서
6) 목 오브젝트 : 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

[9] 결함 관리

1. 결함
-소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것

2. 결함 심각도
-애플리케이션에 발생한 결함이 전체 시스템이 미치는 치명도를 나타내는 척도
-High, Medium, Low 또는 Critical, Major, Normal, Minor, Simple 등으로 분류된다

3. 결함 관리 도구
Mantis, Trac, Redimine, Bugzilla

[10] 애플리케이션 성능 분석

1. 애플리케이션 성능
-최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
-애플리케이션 성능 측정 지표
1) 처리량 : 일정 시간 내에 애플리케이션이 처리하는 일의 양
2) 응답 시간 : 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때 가지 걸린 시간
3) 경과 시간 : 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료 될 때 까지 걸린 시간
4) 자원 사용률 : 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

2. 성능 테스트 도구
- 애플리케이션에 부하나 스트레스를 가하면서 애플리케이션의 성능 측정 지표를 점검하는 도구
-종류
1) JMeter : HTTP, FTP 등 다양한 프로토콜을 지원하는 부하 테스트 도구 (지원환경 : Cross-Platform)
2) LoadUI : 서버 모니터링, Drag&Drop 등 사용자의 핀리성이 강화된 도구, HTTP, JDBC 등 다양한 프로토콜 지원 (지원환경 : Cross-Platform)
3) OpenSTA : HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구 (지원환경 : Window)

3. 시스템 모니터링 도구
- 애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구
- 종류
1) Scouter : 단일 뷰 통합/실시간 모니터링, 튜닝에 최적화된 이프라 통합 모니터링 도구 (지원환경 : Cross-Platform)
2) Zabbix : 웹기반 서버, 서비스, 애플리케이션의 등의 모니터링 도구 (지원환경 : Cross-Platform)
[11] 복잡도

1. 복잡도
-시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말이다
-시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 개발하는 데 어느 정도의 자원이 소요되는지 예측하는 데 사용된다.

2. 시간 복잡도
- 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화 한 것을 의미한다.
- 점근 표기법의 종류
1) 빅오 표기법 : 알고리즘 실행시간이 최악일 때를 표기하는 기법
2) 세타 표기법 : 알고리즘 실행시간이 평균일 때를 표기하는 기법
3) 오메가 표기법 : 알고리즘 실행시간이 최상일 때를 표기하는 기법

3. 빅오 표기법으로 표현한 최악의 알고리즘 시간 복잡도
- O(1) : 스택의 삽입, 삭제
- O(logn) : 이진 트리, 이진 검색
- O(n) : for문
- O(nlogn) : 힙 정렬, 합병 정렬
- O(n^2) : 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬
- O(2^n) : 피보나치 수열

4. 순환 복잡도
- 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도
- 맥케이브 순환도 또는 맥케이브 복잡도 메트릭이라고도 함
-제어 흐름도 이론에 기초를 둔다
- 제어 흐름도 G에서 순환 복잡도 V(G)는 다음과 같은 방법으로 계산할 수 있다.
방법 1) 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산한다
방법 2) V(G) = E - N + 2   (E: 화살표수, N: 노드의 수)


[12] 애플리케이션 성능 개선

1. 소스 코드 최적화
- 나쁜코드 (Bad Code) 를 배제하고, 클린 코드(Clean code)로 작성하는 것이다.
- 클린코드 : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드, 즉 잘 작성된 코드
- 나쁜코드 : 프로그램 로직이 복잡하고 이해하기 어려운 코드
(스파게티 코드 : 로직이 복잡하게 얽혀있음, 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수가 어려운 코드)
-나쁜 코드로 작성된 애플리케이션의 코들르 클린 코드로 수정하면 성능이 향상 된다.

2. 클린코드 작성 원칙
1) 가독성 : 누구든지 코드를 읽을 수 있도록 작성 (ex 쉬운용어, 들여쓰기 등)
2) 단순성 : 코드를 간단하게 작성함, 한번에 한가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리
3) 의존성 배제 : 코드가 다른 모듈에 미치는 영향을 최소화함, 코드 변경 시 다른 부분에 영향이 없도록 함
4) 중복성 최소화 : 코드의 중복을 최소화함
5) 추상화 : 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현함

3. 소스코드 최적화 유형
- 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고, 크기를 작게함
*응집도 : 명령어나 호출문 등 모듈의 내부 요소들이 서료 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
-느슨한 결합(Loosely Coupled) : 인터페이스 클래스를 이용하여 추상화된 자료구조와 메소드를 구현함을써 클래스 간의 의존성을 최소화
*추상화 : 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화 하는것, 즉 모델화 하는것

4. 소스 코드 품질 분석 도구
-소스 코드의 코딩 스타일, 코드에 설정된 코딩표준, 코드의 복잡도, 메모리 누수 현상, 스레드 결함등을 발견하기 위해 사용하는 분석 도구
-정적 분석도구와 동적 분석 도구로 나눔
1) 정적 분석 도구 : 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구
    종류 : pmd, cppcheck, SonarQube, checkstyle, ccm. combertuna 등
2) 동적 분석 도구 : 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구
    종류 : Avalanche, Valgrind 등

5. 소스 코드 품질 분석 도구의 종류
- pmd : 소스 코드에 대한 미사용 변수 , 최적화되지 않은 코드 등 결함을 유발할 수 있는 코드를 검사 (지원환경 : Linux, Windows)
- cppcheck : C/C++ 코드에 대한 메모리 누수, 오버플로우 등을 분석. (지원환경 : Windows)
- SonarQube : 중복 코드, 복자도, 코딩 설계 등을 분석하느 소스 분석 통합 플랫폼 (지원환경 : Cross-Platform)
- checkstyle : 자바 코드에 대해 소스 코드 표준을 따르고 있는지 검사, 다양한 개발 도구에 통합하여 사용 가능 (지원환경 : Cross-Platform)
- ccm : 다양한 언어의 코드 복잡도를 분석 (지원환경 : Cross-Platform)
- cobertuna : 자바 언어의 소스 코드 복잡도 분석 및 테스트 커버리지를 측정 (지원환경 : Cross-Platform)
- Avalanche : valgrind 프레임워크 및 STP 기반으로 구현됨, 프로그램에 대한 결함 및 취약점 등을 분석 (지원환경 : Linux, Android)
- Valgrind : 프로그램 내에 존재하는 메모리 및 쓰레드 결함 등을 분석함

소프트웨어 개발 보안 구축

[1]Secure SDLC

1. Secure SDLC

- SDLC에 보안강화를 위한 프로세스를 포함한 것 (*SDLC : 소프트웨어 개발 생명주기)
- Secure SDLC는 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에서 수행되어야 할 보안 활동을 제시한다.
- Secure SDLC 대표적인 방법론
1) CLASP : SDLC의 초기 단계에서 보안을 강화하기 위해 가발된 방법론
2) SLD : 마이크로소프트 사에서 안전한 소프트웨어 개발을 위해 기존의 SDLC를 개선한 방법론
3) Seven Touchpoints : 소프트웨어 보안의 모범사례를 SDLC에 통합한 방법론

2. SDLC 단계별 보안 활동

1) 요구사항 분석 단계 : 보안 항목에 해당하는 요구사항을 식별하는 작업을 수행함
2) 설계 단계 : 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성함
3) 구현 단계 : 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현함
4) 테스트 단계 : 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작되는지 점검함
5) 유지보수 단계 : 계속해서 보안사고들을 식별하고 사고 발생 시 이를 해결하고 보안 패치를 실시함

3. 소프트웨어 개발 보안 요소

- 기밀성 : 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용됨
- 무결성 : 시스템 내의 정보는 오직 인가된 사용자만 수정 할 수 있음
- 가용성 : 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음
- 인증 : 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위
(대표적인 방법 : 패스워드, 인증용 카드, 지문 검사 등)
-부인 방지 : 데이터 송수신자가 송수신 사실을 부인할 수 없도록 송수진 증거를 제공함

4. 시큐어 코딩 (Secure Coding)

- 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안요소들을 고려하며 코딩하는 것
- 보안 취약점을 사전 대응하여 안전성과 신뢰성을 확보한다.

[2] 세션 통제

1. 세션 통제 (*세선 : 서버와 클라이언트의 연결)
- 세션의 연결과 연결로 인해 발생하는 정보를 관리하는것을 의미
- 소프트웨어 개발 과정 중 요구사항 분석 및 설계 단계에서 진단해야하는 보안 점검 내용이다.
- 세션 통제의 보안 약점
1) 불충분한 세션 관리 : 일정한 규칙이 존재하는 세션ID가 발급되거나 타임아웃이 너무 길게 설정되어 있는 경우 발생하는 보안 약점
2) 잘못된 세션에 의한 정보 노출 : 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점
*멤버 변수 : 객체와 연결된 변수로, 클래스 내에 선언되어 클래스의 모든 메소드들이 접근 가능한 변수, 
멤버 필드라고도 하며 종류에는 클래스변수, 인스턴스변수가 있다.

2. 세션 설계 시 고려 사항
- 시스템의 모든 페이지에서 로그아웃이 가능하도록 UI를 구성
- 로그아웃 요청 시 할당된 세션이 완전히 제거되도록 한다.
- 세션 타임아웃은 중요도가 높으면 2~5분 , 낮으면 15~30분으로 설정한다.
- 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계한다.
- 중복 로그인을 허용하지 않은 경우 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립한다.



3. 세션ID의 관리 방법
- 세션ID는 안전한 서버에서 최소 128비트의 길이로 생성한다.
- 세션ID의 예측이 불가능하도록 안전한 난수 알고리즘을 적용한다.
- 세션ID가 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계한다
*URL Rewrite : 쿠키를 사용할 수 없는 환경에서 세션ID 전달을 위해 URL에 세션ID를 포함시키는 것
- 로그인 시 로그인 전의 세션ID를 삭제하고 재할당한다.
- 장기간 접속하고 있는 세션ID는 주기적으로 재할당되도록 설계한다.

[3] 입력 데이터 검증 및 표현

1. 입력 데이터 검증 및 표현
- 입력 데이터 검증 및 표현은 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들이다.
- 입력데이터 검증 및 표현의 보안 약점
1) SQL 삽입 
 웹 응용 프로그램에 SQL을 삽입하여 내부 DB 서버의 데이터를 유출및 변조하고, 관리자 인증을 우회하는 보안 약점.
 동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링 되도록 설정하여 방지할 수 있음
 *동적 쿼리 : 질의어 코드를 문자열 변수에 넣어 조건에 따라 질의를 만듦

2) 경로 조작 및 자원 삽입
 데이터 입출력 경로를 조작하여 서버 자원을 수정/삭제할 수 있는 보안 약점
 사용자 입력값을 식별자로 사용하는 경우, 경로 순회, 공격을 막는 필터를 사용하여 방지할 수 있음
 *경로 순회 : 경로를 탐색할 때 사용하는 '/','\','..' 등의 기호를 악용하여 허가되지 않은 파일 접근

3) 크로스사이트 스크립팅(XSS)
 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
 HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 '<','>','&' 등의 문자를 다른 문자로 치환함으로써 방지할 수 있음
 *스크립트 : 소프트웨어를 수행하는데 필요한 처리 절차가 기록된 텍스트 ex) asp, jsp, php

4) 운영체제 명령어 삽입
 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증 없이 내부 명령어로 사용하지 않음으로써 방지할 수 있음

5) 위험함 형식 파일 업로드
 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나 시스템을 제어할 수 있는 보안 약점
 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지 할 수 있음

6) 신뢰되지 않는 URL주소로 자동접속 연결
 입력 값으로 사이트 주소를 받는 경우 이를 조작해 방문자를 피싱 사이트로 유도하는 보안 약점
 연결되는 외부 사이트의 주소를 화이트 리스트로 관리해 방지 가능

7) 메모리 버퍼 오버플루
 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 떄 발생하는 보안 약점
 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 설정하고, 설정된 범위의 메모리 내에서 올바르게 읽거나 쓸 수 있도록 함으로써 방지할 수 있음

[4] 보안 기능

1. 보안 기능
- 보안 기능은 소프트웨거 개발의 구현 단계에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항목들이다
- 보안 기능의 보안 약점

1) 적절한 인증 없이 중요기능 허용
 보안 검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능 
 중요정보나 기능을 수행하는 페이지에서는 재인증 기능을 수행하도록 하여 방지할 수 있음

2) 부적절한 인가
 접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취할 수 있음
 모든 실행경로에 대해 접근제어 검사를 수행하고, 사용자에게는 반드시 필요한 접근 권한만을 부여하여 방지 할 수 있음 

3) 중요한 자원에 대한 잘못된 권한 설정
 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있음
 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 사용자에 대한 접근 여부를 검사함으로써 방지 할 수 있음 

4) 취약한 암호화 알고리즘 사용
 암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보를 탈취할 수 있음
 IT 보안인즈사무국이 안정성을 확인한 암호모듈을 이용함으로써 방지할 수 있음

5) 중요정보 평문 저장 및 전송
 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 획득할 수 있음
 중요한 정보를 저장하거나 전송할 때 반드시 암호화하고, HTTPS 또는 SSL과 같은 보안채널을 이용하여 방지
 *HTTPS : HTTP와 암호통신규약을 결합한것 / *SSL : 두 컴퓨터 사이에 인증,암호화,무결성을 보자하는 표준 프로토콜

6) 하드코드된 암호화키
 암호화된 키도 하드코드된 경우 유출 시 역계산 또는 무차별 대입 공격에 의해 탈취될 수 있음
 상수 형태의 암호키보다 암호화 키 생성 모듈 또는 보안이 보자된 외부 공간을 이용함으로써 방지할 수 있음
 *하드코드 : 데이터를 코드 내부에 직접 입력하여 프로그래밍하는 방식 / 무차별 대입 공격 : 암호키를 찾기위해 모든 값을 무차별 대입

[5] 시간 및 상태

1. 시간 및 상태
- 시간 및 상태는 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 
  실행 상태를 관리하여 시스템이 원할하게 동작되도록 하기 위한 보안 검증 항목들이다.
- 시간 및 상태의 보안 약점 

1) TOCTOU 경쟁 조건
 TOCTOU 경쟁 조건은 검사 시점(Time Of Check)과 사용 시점(Time Of Use)을 고려하지 않고 코딩하는 경우 발생하는 보안 약점
 코드 내에 동기화 구문을 사용하여 해당 자원에는 한 번에 하나의 프로세스만 접근 가능하도록 구성함으로써 방지할 수 있음
 *경쟁 조건 : 두 개 이상의 프로세스가 공용 자원을 획득하기 위해 경쟁하고 있는 상태
 *동기화 구문 : 공유 자원에 대해 둘 이상의 프로세스가 접근하는것을 막는 구문으로 Synchronized, Mutex 가 있음

2) 종료되지 않는 반복문 또는 재귀함수
 반복문이나 재귀함수가 종료되지 않을 경우 시스템 자원이 끊임없이 사용되어 자원고갈로 인한 서비스 장애 또는 시스템 장애가 발생한다.
 모든 반복문이나 재귀함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종료 여부를 확인함으로써 방지할 수 있음

[6] 에러처리 (=예외처리)

1. 에러처리
- 에러처리는 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목들이다.
- 에러처리의 보안 약점

1) 오류 메시지를 통한 정보노출
 오류 발생으로 실행 환경, 사용자 정보, 디버깅 정보등의 중요 정보를 소프트웨어가 메시지로 외부에 노출하는 보안 약점
 가능한 한 내부에서만 처리되도록 하거나 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 함으로써 방지할 수 있다.

2) 오류 상황 대응 부재
 소프트웨어 개발 중 예외처리를 하지 않았거나 미비로 인해 발생하는 보안 약점
 오류가 발생할 수 있는 부분에 예외처리 구문을 작성하고, 제어문을 활용하여 오류가 악용되지 않도록 코딩하므로써 방지할 수 있다.

3) 부적절한 예외처리
 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점
 모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외처리를 수행함으로써 방지할 수 있다.

[7] 코드오류

1. 코드오류
- 코드 오류는 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 형변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목들이다.
- 코드 오류의 보안 약점

1) 널 포인터(Null Pointer) 역참조
 널 포인터가 가리키는 메모리에 어떤 값을 저장할 때 발생하는 보안 약점이다.
 널이 될 수 있는 포인터를 이용하거 전에 널 값을 갖고 있는지 검사함으로써 방지할 수 있다.

2) 부적절한 자원 해제
 자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점이다.
 프로그램 내에 자원 반환 코드가 누락되었는지 확인하고, 
 오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지 할 수 있다.

3) 해제된 자원 사용
 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점이다.
 반환된 메모리에 접근할 수 없도록 주소를 저장하고 있는 포인터를 초기화함으로써 방지할 수 있다.

4) 초기화 되지 않은 변수 사용
 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점이다.
 변수 선언 시 할당된 메모리를 초기화함으로써 방지할 수 있다.

2. 스택가드
- 널 포잍너와 역참조와 같이 주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술 중 하나이다.
- 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우 오버플로우로 판단하여
 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막는다

[8] 캡슐화

1. 캡슐화
- 캡슐화는 정보 은닉이 필요한 중요한 데이터와 기능을 불충분하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들
- 캡슐화의 보안 약점

1) 잘못된 세션에 의한 정보 노출
 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점이다.
 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지할 수 있다.

2)제거되지 않고 남은 디버그 코드
 개발 중 버그 수정이나 결과값 확인 위해 남겨둔 코드들로 인해 발생하는 보안 약점이다.
 소프트웨어를 배포하기 전에 코드 검사를 통해 남아있는 디버그 코드를 삭제함으로써 방지할 수 있다.


3) 시스템 데이터 정보 노출
 시스템 데이터 정보 노출은 시스템의 내부 정보를 시스템 메시지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점이다.
 시스템 메시지를 통해 노출되는 메시지는 최소한의 정보만을 제공함으로써 방지 할 수 있다.

4) Public 메소드로부터 반환된 Private 배열
 선언된 클래스 내에서만 접근이 가능한 Private 배열을 모든 클래스에서 접근이 가능한 Public 메소드에서 반환할 때 발생하는 보안 약점이다.
 Private 배열을 별도의 메소드를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지할 수 있다. 

5) Private 배열에 Public 데이터 할당
 Private 배열에 Public으로 선언된 데이터 또는 메소드의 파라미터를 저장할 때 발생하는 보안 약점이다.
 Public으로 선언된 데이터를 Private 배열에 저장할 때, 레퍼런스가 아닌 값을 직접 저장함으로써 방지할 수 있다.
 *래퍼런스 : 전달 또는 할당한다는 것은 메모리의 위치를 공유한다는 의미, B=A 일 경우 배열 B에는 어떠한 값도 저장되지 않았지만 배열 A를 통해 접근가능

2. 접근 제어자
- 외부로부터 접근을 제한하기 위해 사용되는 예약어
접근제어자 / 클래스 내부 / 패키지 내부 / 하위 클래스 / 패키지 외부
Public       /       O        /       O         /        O       /       O
Protected  /       O        /       O         /        O       /       X
Default     /       O        /       O         /        X       /       X
Private     /       O        /        X         /        X       /       X

[9] 암호 알고리즘

1. 암호 알고리즘
- 패스워드, 주민번호, 은행계좌와 같은 중요정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미한다.
- 암호 방식 분류
암호화 방식 -- 양방향 -- 개인키 -- stream 방식
                  l           ㄴ공개키  ㄴBlock 방식
                  ㄴ단방향 -- HASH

2. 개인키 암호화(Private Key Encryption) 기법
- 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법
- 대칭 암호 기법 또는 단일키 암호화 기법이라고도 함
- 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많다
- 개인키 암호화 기법의 종류
1) 스트림 암호화 방식 : 평문과 도일한 길이의 스트림을 생성하여 비트 단위로 암호화 하는 방식
   종류 : LFSR, RC4
2) 블록 암호화 방식 : 한 번에 하나의 데이터 블록을 암호화 하는 방식
   종류 : DES, SEED, AES, ARIA

3. 공개키 암호화(Public Key Encryption) 기법
- 공개키 암호화 기법은 데이터를 암호화할때 사용하는 공개키(Public Key)는 사용자에게 공개하고, 
  복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 관리한다.
- 비대칭 암호 기법이라고도 함
- 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느리다
- 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있다.

4. 양방향 암호화 알고리즘 종류
SEED : 1990년 한국인터넷진흥원 개발한 블록 암호화 알고리즘, 블록 크기는 128비트, 키의 길이에 따라 128, 256으로 분류
ARIA(Academy, Research Institute, Agency) : 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘
DES(Data Encryption Standard) : 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘, 블록 크기는 64비트, 키의 길이 56비트
AES(Advanced Encryption Standard) : 2001년 미국 표준 기술 연구소(NIST)에서 발표한 개인키 암호화 알고리즘, DES의 한계를 느껴 NIST에서 개발, 
RSA(Rivest Shamir Adleman) : 1978년 MIT에 3명에 의해 제안된 공개키 암호화 알고리즘, 큰 숫자를 소인수 분해 하기 어렵다는 것에 기반해 만들어짐

5. 해시
- 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 의미한다.
- 해시 알고리즘은 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라고 부른다.
- 해시 함수의 종류
1) SHA 시리즈
 1993년 미국 국가안보국(NSA)이 설계, 미국 국립표준기술연구소(NIST)에 의해 발표됨
 초기 개발된 SHA-0 이후 SHA-1이 발표되었고, 다시 SHA-2라고 불리는 SHA-224, SHA-256, SHA-384, SHA-512이 발표됨

2) MD5(Message Digest algirithm5)
 1991년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시 함수, 블록 크기가 512비트이며, 키 길이는 128비트임

3) N-NASH
 1989년 일본의 전신전화주식회사(NTT)에서 발표한 암호화 해시 함수, 블록크기와 키 길이가 모두 128비트임

4) SNEFRU
 1990년 R.C.Merkle가 발표한 해시 함수, 32비트 프로세서에서 구현을 용이하게 할 목적으로 개발됨

[10]서비스 공격 유형 

1. 서비스 거부(DoS; Denial of Service) 공격
- 서비스 거부 공격이란 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공겨자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 정상적인 기능을 방해하는 것이다.
- 서비스 거부 공격의 유형에는 Ping of Death, SMURFING, SYN Flooding, TearDrop, Land, DDos 등이 있다.

1) Ping of Death(죽음의 핑)
- Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위(65,536  바이트) 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법이다.
- 공경에 사용되는 큰 패킷은 수백 개의 패킷으로 분할되어 전송되는데, 분할되어 전송된 패킷을 재조립 해야하는 부담과 분할되어 전송된 각각의 패킷들의
  ICMP Ping 메시지에 대한 응답을 처리하느라 시스템이 다운되게 된다

2). SMURFING(스머핑)
- SMURFING은 IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법이다.
- 공격자는 송신 주소를 공격 대상지의 ip 주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신지로 하여 패킷을 전송하면,
  라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송된다.
- 해당 네트워크 내의 모든 컴퓨터는 수신된 패킷에 대한 응답 메시지를 송신주소인 공격 대상지로 집중적으로 전송하게 되는데,
  이로 인해 공격 대상지는 네트워크 과부하로 인해 정상적인 서비스를 수행할 수 없게 된다.
- 각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정해 놓음으로써 방지할 수 있다.

3) SYN Flooding
- TCP는 신뢰성 있는 전송을 위해 3-way-handshake를 거친 후에 데이터를 전송하게 되는데, SYN Flooding은 공격자가 가상의 클라이언트로 위장하여 
  3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법이다.
*3-way-handshake : 1단계 : 송신지에서 수신지로 SYN 패킷 전송 2단계 : 수신지에서 송신지로 SYN+ACK 패킷 전송 3단계 : 송신지에서 수신지로 ACK 패킷전송
- 수신지의 'SYN' 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용한다.

4) TearDrop
- 데이터 송수신 과정에서 패킷의 크기가 커 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, 
  TearDrop은 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부화를 발생시킴으로써 시스템이 다운되도록 하는 공격방법이다.
- Fragment Offset이 잘못된 경우 해당 패킷을 폐기하도록 설정한다.


5). Land Attack
- 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 
  이 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하게 되는데, 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격이다.
- Land에 대비하기 위해 송신 IP 주소와 수신 IP 주소의 적절성을 검사한다.

6). DDoS(Distributed Denial of Service, 분산 서비스 거부) 공격
- DDoS 공격은 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대한 분산 서비스 공격을 수행하는 것으로, 
  네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트로 만든 후 DDoS 공격에 이용한다.
- 분산 서비스 공격용 툴 : 에이전트의 역할을 수행하도록 설계된 프로그램을 데몬이라고 부르며 다음과 같은 종류가 있다
6-1) Trin : 가장 초기 형태의 데몬으로, 주로 UDP Flooding 공격을 수행함
6-2) TFN(Tribe Flood Network) : UDP Flooding 뿐만 아니라 TCP SYN Flood 공격, ICMP 응답요청, 스머핑 공격 등을 수행함
6-3) TFN2K : TFN 의 확장판
6-4) Stacheldraht : 이전 툴들의 기능을 유지하면서, 공격자, 에이전트가 노출되지 않도록 암호화된 통신을 하며 툴이 자동으로 업데이트된다.

2. 네트워크 침해 공격 관련 용어 
1) 스미싱
 - 문자메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법
 - 현재는 행사, 경품 안내 등의 링크를 걸었으나 점차 apk 파일을 설치하도록 유도하여 사용자 정보를 빼가는 수법으로 발전하고 있다.

2) 스피어 피싱
 - 사회 공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 
 - 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해 사용자의 개인 정보를 탈취한다.

3) APT(Advanced Persistent Threats, 지능형 지속 위협)
 - 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 
   정보를 수집한 다음 외부로 빼돌리는 형태의 공격
 - 공격 방법
    ㅇ내부자에게 악성코드가 포함된 이메일을 오랜 기간 동안 꾸준히 발송해 한번이라도 클릭되길 기다리는 형태
    ㅇ스턱스넷(Stuxnet)과 같이 악성코드가 담긴 이동식 디스크(USB) 등으로 전파하는 형태
    ㅇ악성코드에 감염된 P2P 사이트에 접속하면 악성코드에 감염되는 형태 등

4) 무작위 대입 공격
 - 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식  

5) 큐싱(Qshing)
 - QR코드를 통해 악성 앱의 다운로드를 유도하거나 악성 프로그램을 설치한다 낚는다(Fishing)는 의미의 합성 신조어

6) SQL Injection
 - 전문 스캐너 프로그램 혹은 봇넷 등을 이용해 웹사이트를 무차별적으로 공격하는 과정에서 데이터베이스 등의 데이터를 조작하는 공격방식

7) 크로스 사이트 스크립팅(XSS)
 - 네트워크를 통한 컴퓨터 보안 공격의 하나로, 웹 페이지 내용을 사용자 브라우저에 표현하기 위해 사용되는 스크립트의 취약점을 악용한 해킹기법
 - 사용자가 특정 게시물이나 이메일의 링크를 클릭하면 악성 스크립트가 실행되어 페이지가 깨지거나, 사용자의 개인정보가 해커에게 전달된다
8) 스니핑(Sniffing)
 - 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당함

3. 정보보안 침해 공격 관련 용어

1) 좀비PC 
 - 악성코드에 감염되어 다른 프로그램이나 컴퓨터를 조종하도록 만들어진 컴퓨터로, C&C(Command & Control) 서버의 제어를 받아 주로 DDos 공격의 이용

2) C&C서버
 - 해커가 원격지에서 감염된 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 용도로 사용하는 서버를 말함

3) 봇넷
 - 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태를 말함

4) 웜
 - 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높이는 바이러스 일종으로, 분산 서비스 거부 공격, 버퍼 오버플로 공격, 슬래머 등이 있다.
 *버퍼오버플로 : 버퍼의 크기보다 많은 데이터를 입력 , 슬래머 : sql의 허점을 이용하여 sql 서버를 공격하는 웜바이러스의 형태

5) 제로데이 공격
 - 보안 취약점이 발견되었을 때 발견된 취약점의 존재 자체가 공표되기도 전에 해당 취약점을 통해 이루어지는 보안 공격으로, 공격의 신속성을 의미

6) 키로거 공격
 - 사용자의 키보드 움직임을 탐지해 ID, 패스워드, 계좌번호 등과 같은 개인정보를 빼가는 해킹공격

7) 랜섬웨어
 - 사용자 컴퓨터의 잠입해 내부 문서나 파일 등을 암호화하여 사용자가 열지 못하게 하고, 암호 해독용 프로그램 전달을 조건으로 돈을 요구함

8) 백도어
 - 시스템 설계자가 서비스 기술자나 유지 보수 프로그램 작성자(Programmer)의 액세스 편의를 위해 보안을 제거하여 만들어놓은 비밀 통로로 악용되기도 함
 - 백도어탐지 방법 : 무결성 검사, 열린 포트 확인, 로그 분석, SetUID 파일 검사 등

9) 트로이 목마
 - 정상적인 기능을 하는 프로그램으로 위장하여 프로그램 내에 숨어있다가 해당 프로그램이 동작할 때 활성화되어 부작용을 일으키는 것으로, 자기 복제 능력은 없음

[11] 서버 인증

1. 보안 서버
- 보안 서버란 인터넷을 통해 개인정보를 암호화하여 송수신할 수 있는 기능을 갖춘 서버를 말한다.
- 서버에 SSL(Secure Socket Layer) 인증서를 설치하여 전송 정보를 암호화하여 송수신하는 기능
*SSL : 데이터 송수신 하는 컴퓨터 사이 , 즉 TCP/IP 계층과 애플리케이션 계층(HTTP,TELNET,FTP 등) 사이에 위치하여 인증, 암호화, 무결성을 보장하는 업계 표준 프로토콜
- 서버에 암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송수신하는 기능

2. 인증(Authentication)의 개념
- 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차
- 인증에는 네트워크를 통해 컴퓨터에 접속하는 사용자의 등록 여부를 확인하는 것과 전송된 메시지의 위변조 여부를 확인하는 것이 있다.
- 인증의 주요 유형 : 지식 기반 인증, 소유 기반 인증, 생체 기반 인증, 위치 기반 인증


3. 지식 기반 인증
- 사용자가 기억하고 있는 정보를 기반으로 인증을 수행
- 관리 비용이 저렴
- 사용자가 인증 정보를 기억하지 못하면 본인이라도 인증 받지 못한다.
- 고정된 패스워드(Password) : 사용자가 알고 있는 비밀번호를 접속할 때 마다 반복해서 입력한다.
- 패스 프레이즈(Passphrase) : 'iloveyou'와 같이 일반 패스워드보다 길이가 길고 기억하기 쉬운 문장을 활용하여 비밀번호를 구성하는 방법
- 아이핀(i-PIN) : 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호로, 사용자에 대한 신원확인을 완료한 후에 본인확인기관에서 온라인으로 발행한다.

4. 소유 기반 인증
- 소유하고 있는 것을 기반으로 인증을 수행
- 소유물이 쉽게 도용될 수 있으므로 지식 기반 인증 방식이나 생체 기반 인증 방식과 함께 사용된다.
- 신분증 : 사용자의 사진이 포함된 주민등록증 등을 사용하여 사용자의 신분 확인
- 메모리 카드(토큰) : 마그네틱 선에 보안 코드를 저장해서 사용하는 것으로, 카드 리더기를 통해서만 읽을 수 있다.
- 스마트 카드 : 마이크로프로세서, 카드 운영체제 등으로 구성되어 사용자의 정보뿐만 아니라 특정 업무를 처리할 수 있는 기능이 내장되어 있다.
- OTP(One Time Password) : 사용자가 패스워드를 요청할 때마다 암호 알고리즘을 통해 새롭게 생성된 패스워드를 사용하는 것으로, 한 번 사용된 패스워드는 폐기된다.

5. 생체 기반 인증
- 사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것
- 생체 인증 대상 : 지문, 홍채/망막, 얼굴 등

6. 기타 인증 기법
- 행위 기반 인증 : 사용자의 행동 정보를 이용해 인증 수행, (서명, 동작 등)
- 위치 기반 인증 : 인증을 시도하는 위치의 적절성 확인  (콜백, GPS나 IP 주소를 이용한 위치 기반 인증 등)

[12] 보안 아키텍처 / 보안 프레임워크

1. 보안 아키텍처
- 보안 아키텍처란 정보 시스템의 무결성, 가용성, 기밀성을 확보하기 위해 보안 요소 및 보안 체계를 식별하고 이들 간의 관계를 정의한 구조를 말한다.
- 보안 아키텍처를 통해 관리적, 물리적, 기술적 보안 개념의 수립, 보안 관리 능력의 향상, 일관된 보안 수준의 유지를 기대할 수 있다.
- 보안 아키텍처는 보안 수준에 변화가 생겨도 기본 보안 아키텍처의 수정 없이 지원할 수 있어야 한다.
- 보안 아키텍처는 보안 요구사항의 변화나 추가를 수용할 수 있어야 한다.
 
2. 보안 프레임워크
- 보안 프레임워크는 안전한 정보 시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계를 말한다.
- ISO 27001은 정보보안 관리를 위한 국제 표준으로, 일종의 보안 인증이자 가장 대표적인 보안 프레임워크이다.
- ISO 27001은 영국의 BSI가 제정한 BS 7799를 기반으로 구성되어 있다.
- ISO 27001은 조직에 대한 정보보안 관리 규격이 정의되어 있어 실제 심사/인증용으로 사용된다.

[13] 로그 분석

1. 로그(Log)
- 로그란 시스템 사용에 대한 모든 내역을 기록해 놓은 것이다 
- 로그 정보를 이용하면 시스템 침해 사고 발생 시 해킹 흔적이나 공격 기법을 파악할 수 있다.
- 로그 정보를 정기적으로 분석하면 시스템에 대한 침입 흔적이나 취약점을 확인할 수 있다.

2. 리눅스(LINUX) 로그
- 리눅스에서는 시스템의 모든 로그를 var/log 디렉터리에서 기록하고 관리한다.
- 로그 파일을 관리하는 syslogd 데몬은 etc/syslog.conf 파일을 읽어 로그 관련 파일들의 위치를 파악한 후 로그 작업을 시작한다.
- syslog.conf 파일을 수정하여 로그 관련 파일들의 저장 위치와 파일명을 변경할 수 있다.

3. 리눅스의 주요 로그 파일

로그	   파일명	             데몬	                           내용
커널 로그	/dev/console	kernel	커널에 관련된 내용을 관리자에게 알리기 위해 파일로 저장하지 않고 지정된 장치에 표시한다.
부팅 로그 /var/log/boot.log	boot	부팅 시 나타나는 메시지들을 기록한다.
크론 로그	/var/log/cron	crond	작업 스케줄러인 crond의 작업 내역을 기록한다.
시스템 로그/var/log/messages syslogd 커널에서 실시간으로 보내오는 메시지들을 기록한다.
보안 로그	/var/log/secure	xinetd	시스템의 접속에 대한 로그를 기록한다.
FTP 로그	/var/log/xferlog	ftpd	FTP로 접속하는 사용자에 대한 로그를 기록한다.
메일 로그	/var/log/maillog	sendmail propper	송수신 메일에 대한 로그를 기록한다.

4. 윈도우(Windows) 로그

- 이벤트 로그 형식으로 시스템의 로그를 관리한다.
- Windows의 이벤트 뷰어를 이용하여 이벤트 로그를 확인할 수 있다.

 5. Windows 이벤트 뷰어의 로그

응용 프로그램 : 응용 프로그램에서 발생하는 이벤트가 기록된다.
보안 : 로그온 시도, 파일이나 객체 생성, 조회, 제거 등의 리소스 사용과 관련된 이벤트가 기록된다.
시스템 : Windows 시스템 구성 요소에 의해 발생하는 이벤트가 기록된다.
Setup : 프로그램 설치와 관련된 이벤트가 기록된다.
Forwarded Events : 다른 컴퓨터와의 상호 작용으로 발생하는 이벤트가 기록된다.

[14] 보안 솔루션

1. 보안 솔루션의 개념
- 보안 솔루션이란 접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템이다.
- 주요 보안 솔루션에는 방화벽, 침입 탐지 시스템, 침입 방지 시스템, 데이터 유출 방지, 웹 방화벽, VPN, NAC, ESM 등이 있다.
1) 방화벽(Firewall)
- 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용, 거부, 수정하는 기능을 가진 침입 차단 시스템이다.
- 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시킨다.
2) 침입 탐지 시스템(IDS; Intrusion Detection System)
- 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템이다.
- 오용 탐지 : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려준다.
- 이상 탐지 : 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려준다.
3) 침입 방지 시스템(IPS; Intrusion Prevention System)
- 비정상적인 트래픽을 능동적으로 차단하고 격리하는 보안 솔루션이다.
- 침입 방지 시스템은 방화벽과 침입 탐지 시스템을 결합한 것이다.
- 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단한다.
4) 데이터 유출 방지(DLP; Data Leakage/Loss Prevention)
- 내부 정보의 외부 유출을 방지하는 보안 솔루션이다.
5) 웹 방화벽(Web Firewall)
- 일반 방화벽이 탐지하지 못하는 SQL 삽입공격, XSS 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽이다.
- 웹 관련 공격을 감시하고 공격이 웹 서버에 도달하기 전에 이를 차단해 준다
6) VPN(Virtual Private Network, 가상 사설 통신망)
- 공중 네트워크와 암호화 기술을 사용하여 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션이다.
- 암호화된 규경을 통해 인터넷망을 전용선의 사설망을 구축한 것처럼 이용하므로 비용 부담을 줄일 수 있다.
- 원격지의 지사, 영업소, 이동 근무자가 지역적인 제한 없이 업무를 수행 할 수 있다 
7) NAC(Network Access Control)
- 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션이다.
8) ESM(Enterprise Security Management)
- 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션이다.
- 보안솔루션간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.

`응용 SW 기초 기술 활용

[1] 운영체제의 개념

1. 운영체제
- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용가가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.
- 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종이다
- 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 준다
- 프로세스, 기억장치, 주변장치, 파일 등을 관리하는 기능을 수행한다.
- 종류 : Windows, UNIX, LINUX, MacOS, MS-DOS 등
 
2. 운영체제의 목적

-운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신회도 향상, 반환 시간 단축 등이 있다

1) 처리 능력(Thoughput) : 일정 시간 내에 시스템이 처리하는 일의 양. 
2) 반환 시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간. 
3) 사용 가능도(Availabilty) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도. 
4) 신뢰도(Reliabliity) : 시스템이 주어진 문제를 정확하게 해결하는 정도

3. 운영체제의 기능

- 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입출력장치, 파일 및 정보 등의 자원을 관리함. 
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공함. 
- 사용자와 시스템 간의 편리한 인터페이스를 제공함. 
- 시스템의 각종 하드웨어나 네트워크를 관리, 제어함. 
- 데이터를 관리하고 데이터 및 자원의 공유 기능을 제공함. 

[2] 운영체제의 종류

1. Windows

- 1990년대 마이크로소프트 사가 개발한 운영체제.
-  Windows의 주요 특징 
1) 그래픽 사용자 인터페이스(GUI): 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식. 
2) 선점형 멀티태스킹: 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 
  응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료 시키고 모든 시스템 자원을 반환하는 방식. 
3) PnP(Plug and Play, 자동 감지 기능): 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는데 
   필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능. 
4) OLE(Object Linking and Embedding): 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 
  삽입하여 편집할 수 있게 해주는 기능
5) 255자의 긴 파일명: Windows에서 파일 이름은 \ / * ? < > | 를 제외한 모든 문자 및 공백을 사용하여 최대 255자까지 지정할 수 있음
6) Single-User 시스템: 컴퓨터 한 대를 한 사람만이 독점해서 사용함. 

2. UNIX
- 1960년대 AT&T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제. 
- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로 소스가 공개된 개방형 시스템. 
*시분할 시스템 : 여러명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가면서 처리해줌으로써 
  각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는 것
- 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음. 
- 다중 사용자, 다중 작업을 지원함. 
- 트리 구조의 파일 시스템. 

3. UNIX 시스템의 구성

1) 커널
- UNIX의 가장 핵심적인 부분. 
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당. 
- 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 기능 수행. 
2) 쉘
- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기.
- 시스템과 사용자 간의 인터페이스를 담당. 
- 종류 : Bourne Shell, C Shell, Korn Shell
3) 유틸리티 프로그램

- 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용함. 
- DOS에서의 외부 명령어에 해당됨. 
- 종류 에디터, 컴파일러, 인터프리터, 디버거 등이 있음. 
 
4.LINUX

- 1991년 리누즈 토발즈가 UNIX를 기반으로 개발한 운영체제. 
- 프로그램 소스 코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있다
- 다양한 플랫폼에 설치하여 사용이 가능하며, 재배포가 가능함. 
- UNIX와 완벽 호환. 
- 대부분의 특징이 UNIX와 동일.
 
5. MacOS

- 1980년대 애플 사가 UNIX를 기반으로 개발한 운영체제.
- 아이맥과 맥북 등 애플 사에서 생산하는 제품에서만 사용이 가능. 
- 드라이버 설치 및 install uninstall 과정이 단순. 

6. Android

- 구글에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제
- 모든 코드가 공개된 개방형 소프트웨어
- 자바와 코틀린으로 개발 

7. iOS

-애플에서 개발한 유닉스 기반의 모바일 운영체제.
-아이폰, 아이팟 터치, 아이패드 등에 내장
-애플사 고유의 모바일 운영체제라 타사 제품은 탑재 불가 
10.3 운영체제의 기본 명령어

운영체제 기본 명령어의 개요

- 운영체제를 제어하는 방법은 크게 CLI와 GUI로 구분할 수 있음. 

- CLI (Command Line Interface): 키보드로 직접 명령어를 입력하여 작업을 수행하는 사용자 인터페이스.

- GUI (Graphic User Interface): 마우스로 아이콘이나 메뉴를 선택하여 작업을 수행하는 그래픽 사용자 인터페이스

[3] 기억장치 관리

1. 기억장치 관리 전략

- 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치등을 지정하여 한정된 주기억장치공간을 효율적으로 활용하는것
- 종류 : 반입(Fetch)전략, 배치(Placement)전략, 교체(Replacement)전략

2. 반입(Fetch)전략
- 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략
1) 요구반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
2) 예상 반입 : 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

3. 배치(Placement)전략
- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
1) 최초적합(First Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫번째 분할 영역에 배치시키는 방법
2) 최적적합(Best Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 적게 남기는 분할 영역에 배치시키는 방법
3) 최악적합(Worst Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 크게 남기는 분할 영역에 배치시키는 방법

4. 교체(Replacement)전략
- 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 떄,
  이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략이다
- 종류 : FIFO, OPT, LRU, LFU, NUR, SCR 등

[4] 주기억장치 할당 기법

1. 주기억장치 할당
- 프로그램이나 데이터를 실행시키기 위해 주기억 장치에 어떻게 할당할 것인지에 대한 내용
- 분류
1) 연속 할당 기법 : 프로그램이나 주기억장치의 연속으로 할당
    종류 : 단일 분할 할당 기법, 다중 분할 할당 기법
2) 분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
    종류 : 페이징 기법, 세그먼테이션 기법
*분산 할당 기법 : 가상기억장치의 내용을 주기억장치의 할당하기 위한 기법

2. 단일 분할 할당 기법
- 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한순간에눈 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법이다.
- 가장 단순한 기법으로 초기의 운영체제에서 많이 사용한 방법이다
- 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 경계 레지스터가 사용된다
*경계 레지스터(Boundary Register) : 사용자 영역에 있는 사용자 프로그램이 운영체제 영역에 접근 못하도록 보호하는 레지스터, 
 사용자 영역이 시작되는 주소를 가지고있다
- 프로그램 크기가 작을 경우 사용자 영역이 낭비될 수 있다
- 종류
1) 오버레이(Overlay)기법 : 주기억장치보다 큰 사용자 프로그램을 실행히는 기법
2) 스와핑(Swapping)기법 : 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른프로그램과 교채하는 기법

3. 다중 분할 할당 기법
1) 고정 분할 할당 기법 (=정적 할당 기법)
- 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자영역을 
  여러 개의 고정된 크기로 분할하고 준비된 상태에서 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
2) 가변 분할 할당 기법 (=동적 할당 기법)
- 주기억장치를 미리 분할해 놓지 않고 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
- 고정 분할 할당 기법의 단편화를 줄이기 위해 사용됨

[5] 가상기억장치 구현 기법

1. 가상기억장치(Virtual Memory)

- 보조기억장치의 일부를 주기억장치처럼 사욯한는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진것처럼 사용하는 기법
- 프로그램을 여러개의 작은 블록 단위로 나누어 가상기억장치에 보관해 놓고, 
  프로그램 실행 시 요구도니는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일수 있다.
- 블록단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수  있다
- 가상기억장치의 일반적인 구현 방법 : 페이징 기법, 세그멘테이션 기법
*페이징과 세그멘테이션에 가장 큰 차이점 : 세그먼트는 페이징의 비해 크기가 일정하지 않다

2. 페이징(Paging) 기법

- 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동알한 크기로 나눈 후 나눠진 프로그램을 
   동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
- 프로그램을 일정한 크기로 나눈 단위를 페이지라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 한다.
* 페이지의 크기 : 일반적으로 페이지의 크기는 1~4KB이다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생 할 수 있다
* 페이지크기가 4KB이고 프로그램이 17KB라면 3KB의 내부 단편화 발생 가능
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다
* 주소변환 : 가상기억장치에 있는 프로그램이 주기억장치에 적재되어 실행될 떄 논리적인 가상주소를 물리적인 실기억주소로 변환하는 것으로
  주소 사상 또는 주소 매핑이라고도 합니다. 이때 연속적인 가상주소가 반드시 연속적인 실기억주소로 변환되지 않아도 되는데, 이를 인위적 연속성이라 한다.
- 페이지 맵 테이블 사용으로 비용이 증가하고, 처리 속도가 감소된다.

3. 세그멘테이션(Segmentation) 기법
- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 세그멘테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생 할 수 있다.

[6] 페이지 교체 알고리즘

1. 페이지 교체 알고리즘
- 페이지 부재(Page Fault)가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면
  어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는법이 페이지 교체 알고리즘 이다.
- 종류 : OPT, FIFO, LRU, LFU, NUR, SCR 등
* 페이지부재 : CPU가 액세스한 가상 페이지가 주기억장치에 없는 경우를 말한다. 페이지 부재가 발생하면 해당 페이지를 디스크에서 주기억 장치로 가져온다

2. OPT(OPTimal replacement, 최적 교체)
 
- OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.
- 벨레이디(Belady)가 제안한 기법이다.
- 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.

3. FIFO(First In First Out)

- 각 페이지가 주기억장치에 적재될 때마다 그떄의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다.
- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다

4. LRU(Least Recently Used)

- LRU는 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.
- 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현시저에서 가장 오랫동안 사용하지 않은, 즉 가장 오래전에 사용된 페이지를 교체한다.
* 계수기 : 각 페이지별로 존재하는 논리적 시계로, 해당 페이지가 사용될 때마다 0으로 클리어 시킨 후 시간을 증가시켜서 시간이 가장 오래된 페이지를 교체한다.

5. LFU(Least Frequently Used)

- LFU는 사용 빈도가 가장 적은 페이지를 교체하는 기법이다
- 활발하게 사요되는 페이지는 사용횟수가 많아 교체되지 않고 사용된다.

6. NUR(Not Used Recently)

- NUR은 LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법이다.
- 최근에 사용되지 않은 페이지는 나중에도 사용되지 않을 가능성이 높다는 전제로 LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두개의 비트, 즉 참조비트와 변형비트가 사용된다
* 참조비트(Reference Bit) : 페이지가 호출되지 않았을때는 0, 호출되었을때는 1로 지정됨
* 변형비트(Modified Bit) : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을때는 1로 지정됨.
- 다음과 같이 참조 비트와 변형 비트의 값으 따라 교체될 페이지의 순서가 결정된다.
참조비트 : 0/0/1/1
변형비트 : 0/1/0/1
교체순서 : 1/2/3/4

7. SCR(Second Chance Replacement, 2차 기회 교체)

- SCR은 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법이다.
- FIFO 기법의 단점을 보완하는데 사용된다.

[7] 가상기억장치 기타 관리 사항

1. 페이지 크기
- 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에 따라 시스템에 미치는 영향이 다르다.
1) 페이지 크기가 작을 경우
0 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
0 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있다.
0 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
0 디스크 접근 횟수가 많아져서 전체적인 입출력 시간은 늘어난다.

2)페이지 크기가 클 경우
0 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
0 디스크 접근 횟수가 줄어들어 전체적인 입출력의 효율성이 증가된다.
0 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.

2. Locality

- Locality(국부성, 지역성, 구역성, 국소성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론이다.
- 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다.
- 가상기억장치 관리와 캐시 메모리 시스템의 이론적인 근거가 된다.
- 데닝(Denning) 교수에 의해 구역성의 개념이 증명되었다.
- Locality의 종류
1) 시간 구역성(Temporal Locality)
0 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상이다.
0 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미한다.
2) 공간 구역성(Spatial Locality)
0 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상이다.
0 어느 하나 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미한다.

3. 워킹 셋(Working Set)
- 워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합이다.
- 데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용한다.
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다.

7. 스래싱(Thrashing)
- 스래싱은 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상이다.
- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 
   페이지 부재가 자주 발생함으로써 나타나는 현상으로, 전체 시스템 성능이 저하된다.
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만,
  다중 프로그래밍의 정도가 더욱 커지면 스레싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다.
* 다중 프로그래밍의 정도 : 얼마나 많은 프로그램이 동시에 수행되는가를 나타내는 것

[8] 프로세스의 개요

1. 프로세스(Process)

- 프로세스는 일반적으로 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미한다.
- 프로세스는 다음과 같이 여러가지로 정의 할 수 있다.
1) PCB를 가진 프로그램
2) 실기억장치에 저장된 프로그램
3) 프로시저가 활동 중인것
4) 비동기적 행위를 일으키는 주체
5) 지정된 결과를 얻기 위한 일련의 계통적 동작
6) 목적 또는 결과에 따라 발생되는 사건들의 과정
7) 운영체제가 관리하는 실행 단위
* 프로시저 : 한 프로그램은 여러개의 작은 프로그램으로 분할 될 수 있는데, 이 떄 분할된 작은 프로그램을 의미한다.
* 비동기적 행위 : 다수의 프로세스가 서로 규칙적이거나 연속적이지 않고 독립적으로 실행되는것

2. PCB(Process Control Block, 프로세스 제어 블록)

- PCB는 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳이다.
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCV는 제거된다
- PCB의 저장되어 있는 정보
1) 프로세스의 현재 상태
2) 포인터
3) 프로세스 고유 식별자
4) 스케줄링 및 프로세스의 우선순위
5) CPU레지스터 정보
6) 주기억장치 관리 정보
7) 입출력 상태 정보
8) 계정 정보

3. 프로세스 상태 전이
- 프로세스 상태 전이는 프로세스가 시스템 내에 존재하는 동안 프로세스 상태가 변하는것을 의미한다. 
- 프로세스의 상태는 다음과 같이 상태 전이도로 표시할 수 있다.
https://velog.io/@mainxcharacter/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EC%9A%94
1) 제출(Submit): 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
2) 접수(Hold): 제출된 작업이 스풀 공간인 디스크 할당 위치에 저장된 상태
3) 준비(Ready): 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
4) 실행(Run): 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
5) 대기(Wait), 블록(Block): 프로세스에 입출력처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될때까지 대기하고 있는 상태
6) 종료(Terminated Exit): 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태이다.

4. 프로세스 상태 전이 관련 용어
- Dispatch : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
- Wake Up : 입 출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
- Spooling : 입 출력 장치의 공유 및 상대적으로 느린 입출력 장치의 처리속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해
  입 출력할 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정
- 교통량 제어기 : 프로세스의 상태에 대한 조사와 통보 담당

5. 스레드(Thread)
- 스레드는 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 또는 프로세스 내에서의 작업 단위로 사용된다.
- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다.
- 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고도 한다.
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.

[9] 스케줄링(Scheduling)

1. 스케줄링

- 스케줄링은 프로세스가 생성되어 실행될 떄 필요한 시슨템의 여러 자원을 해당 프로세스에게 할당 시키는 작업을 의미한다.
- 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링의 과정을 거치게 된다
- 스케줄링의 종류
1) 장기 스케줄링 : 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 아래 준비 상태 큐로 보내는 작업
2) 중기 스케줄링 : 어떤 프로세스들이 CPU를 할당받을 것인지를 결정하는 작업
3) 단기 스케줄링 : 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업

2. 스케줄링의 목적
1. 공정성: 모든 프로세스에 공정하게 할당함.
2. 처리율(량) 증가: 단위 시간 당 프로세스를 처리하는 비율(양)을 증가시킴.
3. CPU 이용률 증가: 프로세스 실행 과정에서 주 기억장치를 액세스한다든지, 입출력 명령 실행 등의 원인에 의해 발생할 수 있는 CPU의 낭비 시간을 줄이고, CPU가 순수하게 프로세스를 실행하는데 사용되는 시간 비율을 증가시킴.
4. 우선순위 제도 : 우선순위가 높은 프로세스를 먼저 실행함.
5. 오버헤드 최소화 : 오버헤드를 최소화함.
6. 응답시간 최소화 : 작업을 지시하고 반응하기 시작하는 시간을 최소화함.
7. 반환시간 최소화 : 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간을 최소화함.
8. 대기시간 최소화 : 프로세스가 준비상태 큐에서 대기하는 시간을 최소화함.
9. 균형있는 자원의 사용 : 메모리, 입출력장치 등의 자원을 균형있게 사용함.
10. 무한 연기 회피 : 자원을 사용하기 위해 무한정 연기되는 상태를 회피함.


3. 비선점 스케줄링
1) 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법.
2) 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될때까지 CPU를 사용함.
3) 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합.
4) 종류 : FCFS, SJF, 우선순위, HRN, 기한부 등

4. 선점 스케줄링
1) 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때, 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.
2) 우선순위가 높은 프로세스를 빠르게 처리할 수 있음.
3) 주로 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용됨.
4) 많은 오버헤드를 초래함.
5) 종류: 라운드 로빈(Round Robin), SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등

[10] 주요 스케줄링 알고리즘

1. FCFS(First Come First Service,선입 선출) =FIFO
- 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
- 가장 간단한 ㅏㄹ고리즘이다.

2. SJF(Shortest Job First, 단기 작업 우선)
- 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할단하는 기법
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이다.

3. HRN(Hightest Response-ratio Next)
- 대기 시간과 서비스(실행) 시간을 이용하는 기법
- 실행 시간이 긴 프로세스에게 불리한 SJF 기법을 보완하기 위한 것이다.
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다.
- 우선순위 계산식 = (대기시간+서비스시간)/서비스 시간

[11] 환경변수

1. 환경변수(Environment Variable)
- 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임
- 환경 변수는 변수명과 값으로 구성
- 환경 변수는 시스템의 기본 정보를 저장
- 환경 변수는 자식 프로세스에 상속
- 환경 변수는 시스템 전반에 걸쳐 적용되는 시스템 환경 변수와 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분

2. Windows의 주요 환경 변수
- Windows에서 환경변수를 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 '%'를 입력해야 한다.
- Windows에서 set을 입력하면 모든 환경 변수와 값은 출력한다.
%ALLUSERPROFILE% - 모든 사용자 프로필이 저장된 폴
%APPDATA% - 설치된 프로그램의 필요 데이터가 저장된 폴더 
%COMSPEC% - 기본 명령 프롬프트로 사용할 프로그램명
%HOMEDRIVE% - 로그인한 계정의 정보가 들어있는 드라이브
%HOMEPATH% - 로그인한 계정의 기본 폴더
%LOGONSERVER% - 로그인한 계정이 접속한 서버명
%PATH% - 실행 파일을 찾는 경로
%PATHEXT% - cmd에서 실행할 수 있는 파일의 확장자 목록
%PROGRRAMFILES% - 기본 프로그램 설치 폴더
%SYSTEMRIVE% - Windows가 부티된 드라이브
%SYSTEMROOT% - 부팅된 운영체제가 들어 있는 폴더
%TEMP% 또는 %TMP% - 임시 파일이 저장되는 폴더
%USERDOMAIN% - 로그인한 시스템의 도메인 명
%USERNAME% - 로그인한 계정 이름
%USERPROFILE% - 로그인한 유저의 프로필이 들어있는 폴더명

3. UNIX / LINUX의 주요 환경 변수
- UNIX나 LINUX에서 환경변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 '$'를 입력해야 한다.
- UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시한다.
$DISPLAY : 현재 X 윈도 디스플레이 위치
$HOME : 사용장의 홈 디렉터리
$LANG : 프로그램 사용 시 기본적으로 지원되는 언어
$MAIL : 메일을 보관하는 경로
$PATH : 실행 파일을 찾는 경로
$PS1 : 쉘 프롬프트 정보
$PWD : 현재 작업하는 디렉터리
$TERM : 로긴 터미널 타입
$USER : 사용자의 이름
* X윈도 : X윈도는 UNIX계열의 운영체제에서 GUI기반의 시스템 소프트웨어를 의미합니다.

[12] 운영체제 기본 명령어

1.Windows 기본 명령어
10.3 운영체제의 기본 명령어

운영체제 기본 명령어의 개요

1. Window 기본 명령어
- DIR : 현재 디렉토리 파일 목록 표시 
DIR의 옵션
/P	목록을 한 화면 단위로 표시
/W	목록을 가로로 나열하여 표시
/O	지정한 정렬 방식으로 표시 (D: 날짜 시간, E: 확장자, N: 파일 이름, S: 파일 크기)
/S	하위 디렉터리의 정보까지 표시
/A	지정한 속성이 설정된 파일 목록 표시
- COPY: 파일 복사 copy abc.txt gilbut  abc.txt 파일을 gilbut 디렉토리로 복사
- DEL: 파일 삭제  del abc.txt
- TYPE: 파일의 내용 표시 type abc.txt
- REN: 파일의 이름 변경 ren abc.txt 123.txt
- MD: 디렉토리 생성 md gilbut
- CD: 동일한 드라이브에서 디렉터리 위치 변경 cd gilbut
- CLS: 화면의 내용을 지움
- ATTRIB: 파일의 속성을 변경 attrib +r abc.txt
속성의 종류
R	읽기 전용 속성
A	저장/백업 속성
S	시스템 파일 속성
H	숨김 파일
 	속성을 지정할 때는 속성 앞에 +, 속성을 해제할 때는 속성 앞에 -를 입력
- FIND: 파일에서 문자열 찾음 find "123" abc.txt
- CHKDSK: 디스크 상태 점검
- FORMAT: 디스크 표면을 트랙과 섹터로 나누어 초기화 함. format c: c 드라이브를 초기화
- MOVE: 파일을 이동 move abc.txt gilbut
 
2. UNIX/LINUX 기본 명령어

- cat: 파일 내용을 화면에 표시 cat abc.txt
- cd: 디렉토리 위치 변경 cd gilbut
- chmod: 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정함.  chmod u=rwx abc.txt
사용자	u: user (소유자)
g: group(그룹)
o: other (다른 사용자)
a: all (모두)
설정 기호	+ : 권한 추가
- : 권한 삭제
= : 권한 부여
권한	r: read (읽기)
w: write (쓰기)
x: execute (실행)
- chown: 파일의 소유자와 그룹을 변경  chown  member1 abc.txt 
- cp: 파일 복사  cp abc.txt gilbut/abc2.txt 
- rm: 파일 삭제  rm abc.txt 
- find: 파일 찾기  find abc.txt
- fsck: 파일 시스템 검사하고 보수  fsck /dev/sda 
- kill: PID를 이용하여 프로세스 종료  kill 1234 
- killall: 프로세스 이름을 이용하여 프로세스 종료  killall gilbut 
- Is: 현재 디렉토리 파일 목록 표시 
- mkdir: 디렉토리 생성 mkdir gilbut 
- rmdir: 디렉토리 삭제 rmdir gilbut 
- mv: 파일을 이동 mv abc.txt gilbut/abc2.txt 
- ps: 현재 실행중인 프로세스 표시
- pwd: 현재 작업중인 디렉토리 경로를 화면에 표시
- top: 시스템의 프로세스와 메모리 사용 현황 표시
- who: 시스템에 접속해있는 사용자 표시

[13] 인터넷

1. 인터넷
- TCP/IP 프로토콜(인터넷의 표준 프로토콜)을 기반으로 하여 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망. 
- 인터넷에 연결된 모든 컴퓨터는 고유 IP주소를 가짐. 

2. IP주소
- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소. 
- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있음. 
- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 총 5 단계로 구성되어 있음. 
A 클래스 : 국가나 대형 통신망에 사용.
0~127로 시작(0번과 127번은 예약어이므로 실질적으로 1~126으로 시작). 
224= 16,777,216개의 호스트 사용 가능
B 클래스 : 중대형 통신망에 사용 
128~191로 시작
216= 65,536개의 호스트 사용 가능
C 클래스 : 소규모 통신망에 사용
192~233으로 시작
28= 256개의 호스트 사용 가능
D 클래스 : 멀티캐스트용으로 사용
* 멀티캐스트 : 한 명 이상의 송신자들이 특정한 한 명 이상의 수신자들에게 데이터를 전송하는 방식으로 인터넷 화상 회의 등에서 사용됨
224~239로 시작
E 클래스 : 실험적 주소이며 공용되지 않음

3. 서브넷팅(Subnetting)
- 서브넷팅은 할당된 네트워크 주소를 다시 여러개의 작은 네트워크로 나누어 사용하는 것.
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크라고 하며,
  이를 변경하여 네트워크 주소를 여러개로 분할하여 사용한다.
- 서브넷 마스크는 각 클래스마다 다르게 사용된다.

4. IPv6 (Internet Protocol version6)

- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발됨. 
- IPv4에 비해 자료 전송 속도가 빠름. 
- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있다.
- IPv4와 호환성이 뛰어남. 
- 인증성(사용자의 식별과 접근 권한 검증), 기밀성(시스템 내의 정보와 자원은 인가된 사용자에게만 접근 허용), 데이터 무결성(시스템 내의 정보는 인가된 사용자만 수정 가능)의 지원으로 보안 문제를 해결할 수 있음. 
- 주소의 확장성, 융통성, 연동성이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원함. 
- 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다
- 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이하다.

5. IPv6의 구성
16 비트씩 8 부분, 총 128비트로 구성되어 있음. 
각 부분을 16진수로 표현하고, 콜론(:)으로 구분함
세가지 주소 체계로 나뉨
유니캐스트(Unicast)   단일 송신자와 단일 수신자 간의 통신. 일대일 통신에 사용. 
멀티캐스트(Multicast) 단일 송신자와 다중 수신자 간의 통신. 일대다 통신에 사용. 
애니캐스트(Anycast)   단일 송신자와 가장 가까이 있는 단일 송신자 간의 통신. 일대일 통신에 사용.
 
6. 도메인 네임

- 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것. 
- 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미함. 
- 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)
  라고 하며 이런 역할을 하는 서버를 DNS 서버라고 함. 

[14] OSI 참조 모델

1. OSI(Open System Interconnection) 참조 모델

- OSI 참조 모델은 다른 시스템 간의 원활한 통신을 위해 ISO(국제 표준화 기구)에서 제안한 통신 규약(Protocol)이다. 
- 개방형 시스템 간의 데이터 통신 시 필요한 장비 및 처리 방법을 7단계로 표준화하여 규정함. 
- OSI 7 계층: 1-3 계층은 하위 계층, 4-7 계층은 상위 계층 (물데네 전세표응)
하위 계층: 물리 계층 → 데이터 링크 계층 → 네트워크 계층
상위 계층: 전송 계층 → 세션 계층 → 표현 계층 → 응용 계층
 
2. 물리 계층(Physical Layer)

- 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함
- 물리적 전송 매체와 전송 싱호 방식을 정의한다.
- 물리적 전송 매체와 전송 신호 방식을 정의하며, RS-232C, X, 21등 표준이 있음. 
- 관련 장비: 리피터, 허브

3. 데이터 링크 계층 (Data Link Layer)

- 데이터 링크 계층은 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보를 전송할 수 있도록 시스템 연결과 유지, 종류를 담당. 
- 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능
- 프레임의 시작과 끝을 구분하기 위한 프레임 동기화 기능. 
- 오류의 검출과 회복을 위해 오류 제어기능 
- 프레임의 수서적 전송을 위한 순서 제어 기능
- HDLX, LAPB, LLC, MAC, LAPD, PPP 등의 표준이 있음
- 관련 장비: 랜카드, 브리지, 스위치

4. 네트워크 계층 (Network Layer, 망 계층)
- 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함. 
- 네트워크 연결을 설정, 유지, 해제하는 기능을 함. 
- 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행. 
- X.25, IP 등의 표준이 있음. 
- 관련 장비: 라우터

5. 전송 계층 (Transport Layer)
- 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단(End-to-End) 시스템 간에 투명한 데이터 전송을 가능하게 함. 
- 전송 계층의 서비스 등급: 전송 계층은 네트워크의 형을 A, B, C 형으로 나누고 서비스 등급을 0-4까지 5등급으로 나누어 네트워크형에 따라 다양한 서비스 품질을 제공함. 
- OSI 7계층 중 하위 3 계층과 상위 3계층의 인터페이스를 담당함. 
- 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 함. 
- 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행. 
- TCP, UDP 등의 표준이 있음. 
- 관련 장비: 게이트웨이

6. 세션 계층 (Session Layer)
- 송수신 측 간의 관련성을 유지하고 대화 제어를 담당함. 
- 세션: 두 이용자 사이의 연결을 의미. 연결을 원하는 두 이용자 사이의 세션 설정 및 유지를 가능하게 해 줌으로써 두 이용자 간의 대화를 관리하고, 파일 복구 등의 기능을 지원. 
- 대화 구성 및 동기 제어, 데이터 교환 관리 기능을 함. 
- 동기점: 송수신 측 간의 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크점을 두어 정보의 수신 상태를 체크하는 지점. 오류가 있는 데이터의 회복을 위해 사용하는 것
소동기점: 하나의 대화 단위 내에서 데이터의 전달을 제어하는 역할. 수신측으로부터 확인신호(AOK)를 받지 않음. 
대동기점: 전송하는 각 데이터의 처음과 끝에 사용하여 전송하는 데이터 단위를 대화 단위로 구성하는 역할을 하며, 수신측으로부터 반드시 전송한 데이터에 대한 확인신호를 받음. 

7. 표현 계층 (Presentation Layer)
- 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함. 
- 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층. 
- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 기능을 함. 

8. 응용 계층 (Application Layer)
- 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공. 
- 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공. 

[15] 네트워크 관련 장비
 
1. 네트워크 인터페이스 카드(NIC)
- 컴퓨터와 컴퓨터, 또는 컴퓨터와 네트워크를 연결하는 장치. 
- 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함. 
- 이더넷 카드(LAN카드) 혹은 네트워크 어댑터라고도 함. 

2. 허브(Hub)
- 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치. 
- 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함됨. 
- 허브의 종류: 더미 허브, 스위칭 허브 
1) 더미 허브 (Dummy Hub) : 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공.  
2) 스위칭 허브 (Switching Hub) : 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브. 

3. 리피터(Repeater)
- 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행. 
- 물리 계층에서 동작하는 장비
- 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용.

4. 브리지(Bridge)
- LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)를 연결하는 기능을 수행. 
 - 네트워크 상의 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있음. 
- 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음. 
- 브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때, n(n-1)/2 개.

5. 스위치(Switch)
- LAN과 LAN을 연결하여 더 큰 LAN을 만드는 장치. 
- 하드웨어를 기반으로 처리하므로 전송 속도가 빠름. 
- 포트마다 각기 다른 전송 속도를 지원하도록 제어할 수 있고, 수십에서 수백개의 포트를 제공.
- 데이터 링크 계층에서 사용. 

6. 라우터(Router)

- 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것
- 서로 다른 LAN이나 LAN과 WAN의 연결도 수행. 
- 네트워크 계층에서 동작하는 장비. 
- 3계층, 즉 네트워크 계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행. 

7. 게이트웨이(Gateway)
- 전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행.
- 세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행. 
- LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할. 

[16] TCP/IP

1. 프로토콜(Protocol)

- 프로토콜은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜놓은 통신 규약이다.
* 프로토콜 : 1965년 톰 마릴이 메시지전달과 도착을 확인하는 일련의 방법을 기술작 은어란 뜻의 프로토콜을 정의하였다.
- 프로토콜의 기본 요소
1) 구문(Syntax) : 전송하고자 히는 데이터의 형식, 부호화, 신호 레벨 등을 규정함
2) 의미(Semantics) : 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정.
3) 시간(Timing) : 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정. 

2. TCP/IP

- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜. 
- TCP 프로토콜(Transmission Control Protocol)
1) 신뢰성 있는 연결형 서비스를 제공. 
2) 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공. 
3) OSI 전송계층에 해당
- IP 프로토콜(Internet Protocol)
1) 데이터 그램을 기반으로 하는 비연결형 서비스를 제공. 
2) 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공
3) OSI7게층의 네트워크 계층에 해당

3. TCP/IP의 구조

OSI	              TCP/IP	                                  기능
------------------------------------------------------------------------------------------------
응용 계층
표현 계층             응용 계층	응용 프로그램 간의 데이터 송수신을 제공
세션 계층  	                         (예) TELNET, FTP, SMTP, SNMP, DNS, HTTP 
------------------------------------------------------------------------------------------------
전송 계층 	전송 계층	             호스트들 간의 신뢰성 있는 통신 제공
                                                  (예) TCP, UDP, RTCP
------------------------------------------------------------------------------------------------
네트워크 계층	인터넷 계층	데이터 전송을 위한 주소 지정, 경로 설정을 제공
                                                   (예) IP, ICMP, IGMP, ARP, RARP
------------------------------------------------------------------------------------------------
데이터 링크 계층     네트워크             실제 데이터(프레임)을 송수신하는 역할을 함. 
물리계층	              엑세스 계층         (예) Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ
------------------------------------------------------------------------------------------------

4. 응용 계층의 주요 프로토콜
- FTP(File Transfer Protocol) : 컴퓨터와 컴퓨터, 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있는 원격 파일 전송 프로토콜.
- SMTP (Simple Mail Transfer Protocol) : 전자 우편을 교환하는 서비스.
- TELNET : 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스.
              프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행. 
- SNMP (Simple Network Management Protocol) : TCP/IP의 네트워크 관리 프로토콜.  라우터나 허브 등 네트워크 기기의 
                                                                   네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약. 
- DNS (Domain Name System) : 도메인 네임을 IP 주소로 매핑하는 시스템. 
- HTTP (Hyper Text Transfer Protocol) : 월드 와이드 웹(WWW)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜. 

5. 전송 계층의 주요 프로토콜

- TCP(Transmission Control Protocol)
양방향 연결형(Full Duplex Connection) 서비스를 제공. 
가상 회선 연결 형태의 서비스 제공. 
스트림 위주의 전달(패킷 단위)을 함. 
신뢰성 있는 경로를 확립하고 메시지 전송을 감독. 
순서 제어, 오류 제어, 흐름 제어 기능을 함. 
패킷의 분실, 손상, 지연이나 순서가 틀린 것이 발생할 때 투명성이 보장되는 통신을 제공. 
TCP프로토콜의 헤더는 20Byte에서 60Byte 까지 사용할 수 있는데, 선택적으로 40추가하여 100byte까지 확장할 수 있다.
TCP를 사용하는 서비스: FTP, SMTP, TELNET, HTTP 등

- UDP(User Datagram Protocol)
데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스 제공. 
TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 오버헤드가 적고, 흐름 제어나 순서제어가 없어 전송속도가 빠름 
고속의 안정성 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달하는 경우, 정기적으로 반복해서 전송할 경우에 사용됨. 
실시간 전송에 유리하며, 신뢰성 보다는 속도가 중요시 되는 네트워크에서 사용. 
UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함.

- RTCP(Real-Time Control Protocol)
RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜.
세션에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송. 
하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화를 제공. 
데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공. 
RTCP 패킷은 항상 32비트의 경계로 끝남. 

- TCP와 UDP 비교
TCP는 데이터 전송 시 수신 가능 상태, 수신 여부 등을 지속적으로 확인하기 때문에 신뢰성이 보장되어야하는 전송 작업에 적합
UDP는 데이터를 전송만 할 뿐 확인 과정을 거치지 않기 때문에 빠른 데이터 전송 작업에 적합. 
프로토콜   	TCP	       UDP
연결성	     연결형 서비스	    비연결형 서비스
신뢰성	          높음	       낮음
속도	          느림	       빠름
패킷 교환 방식	가상 회선 방식	데이터그램 방식
수신(재전송)	수신함	        수신 안함
통신 방식	               1:1	1:1, 1:N, N:N
용도	신뢰성 요구 작업	실시간 전송 작업

6. 인터넷 계층의 주요 프로토콜

- IP(Internet Protocol)
전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능.
비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음.
* IP의 비신뢰성: 패킷이 목적지에 성공적으로 도달하는 것을 보장하지 않음. IP는 최선의 서비스를 목적으로 하는 프로토콜로, 신뢰성에 대한 요구는 TCP와 같은 상위 계층에서 제공. 

- ICMP(Internet Control Message Protocol, 인터넷 제어 메시지)
IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경등을 위한 제어 메시지를 관리하는 역할. 
헤더는 8Byte로 구성

- IGMP(Internet Group Management Protocol, 인터넷 그룹 관리)
멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용.

- ARP(Address Resolution Protocol, 주소 분석)
호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC address, 랜 카드 고유 번호)로 바꿈. 
*물리적 주소(MAC Address) : 랜 카드 제작사에서 랜 카드에 부여한 고유 번호
- RARP(Reverse Address Resolution Protocol)
APR와 반대로 물리적 주소를 IP주소로 변환. 
 
7. 네트워크 엑세스 계층의 주요 프로토콜
- Ethernet(IEEE 802.3) : CSMA/CD 방식의 LAN
- IEEE 802 : LAN을 위한 표준 프로토콜
- HDLC : 비트 위주의 데이터 링크 제어 프로토콜.
- X.25 : 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- RS-232C : 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜

[17] 네트워크 관련 신기술

1. 네트워크 관련 신기술

1) IoT(사물인터넷) 
정보 통신 기술을 기반으로 실세계와 가상 세계의 다양한 사물들을 인터넷으로 서로 연결하여 진보된 서비스를 제공하기 위한 서비스 기반 기술.

2) M2M(Machine to Machine, 사물 통신)
M2M은 무선통신을 이용한 기계와 기계 사이의 통신.

3) 모바일 컴퓨팅(Mobile Computing)
휴대형 기기로 이동하면서 자유롭게 네트워크에 접속하여 업무 처리 가능한 환경.

4) 클라우드 컴퓨팅(Cloud Computing)
각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 환경

5) 모바일 클라우드 컴퓨팅(MCC; Mobile Cloud Computing)
클라우드 서비스를 이용하여 소비자와 소비자의 파트너가 모바일 기기로 클라우드 인프라를 구성하여 여러 가지 정보와 자원을 공유하는 ICT 기술을 의미함.

6) 인터클라우드 컴퓨팅(Inter-Cloud Computing)
각기 다른 클라우드 서비스를 연동하거나 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술

7) 메시 네트워크(Mesh Network) 
차세대 이동통신, 홈네트워킹 등 특수 목적을 위한 새로운 방식의 네트워크 기술로, 대규모 디바이스의 네트워크 생성에 최적화되어 있다.

8) 와이선(Wi-Sun)
스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물 인터넷 서비스를 위한 저전력 장거리(LPWA; Low-Power Wide Area) 통신 기능

9) NDN(Named Data Networking)
콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술로, 기존의 IP 망을 대체할 새로운 인터넷 아키텍처로 떠오르고 있음

10) NGN(Next Generation Network, 차세대 통신망)
ITU-T에서 개발하고 있는 유선망 기반의 차세대 통신망으로, 이동 사용자를 목표로 하며, 이동통신에서 제공하는 완전한 이동성제공을 목표로 개발되고 있음

11) SDN(Software Defined Networking, 소프트웨어 정의 네트워킹)
네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어들로 네트워킹을 가상화하여 제어하고 관리하는 네트워크

12.)NFC(Near Field Communication, 근거리 무선 통신)
고주파(HF)를 이용한 근거리 무선 통신 기술

13). UWB(Ultra WideBand, 초광대역)
짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술로 무선 디지털 펄스라고도 하며, 블루투스와 비교되는 기술이다.

14) 피코넷(PICONET)
여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술이다.

15) WBAN(Wireless Body Area Network)
웨어러블 또는 몸에 심는(Implant) 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술

16) GIS(Geographic Information System, 지리 정보 시스템)
지리적인 자료를 수집, 저장, 분석, 출력할 수 있는 컴퓨터 응용 시스템으로, 위성을 이용해 모든 사물의 위치 정보를 제공해 주는 것

17) USN(Ubiquitous Sensor Network, 유비쿼터스 센서 네트워크)
각종 센서로 수집한 정보를 무선으로 수집할 수있도록 구성한 네트워크를 말한다. 즉, 필요한 모든 것에 RFID 태그를 부착하고, 이를 통해 사물의 
인식 정보는 물론 주변의 환경정보까지 탐지하여 이를 네트워크에 연결하여 정보를 관리하는 것을 의미한다.

18) SON(Self Organizing Network, 자동 구성 네트워크)
SON은 주변 상황에 맞춰 스스로 망을 구성하는 네트워크

19) 애드 혹 네트워크(Ad-hoc Network)
애드 혹 네트워크는 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크로, 
망 구성 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.

20) 네트워크 슬라이싱(Network Slicing)
3GPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G의 핵심기술 중 하나로, 네트워크에서 하나의 물리적인 코어 네트워크 인프라를 독립된 다수의 
가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크 기술이다.

21) 저전력 블루투스 기술(BLE; Blutooth Low Energy)
일반 블루투스와 비슷하지만 연결되지 않은 대기 상태에서 절전 모드를 유지하는 기술이다.

22) 지능형 초연결망
스마트 시티, 스마트 스테이션 등 4차 산업혁명 시대를 맞아 급격하게 증가하는 데이터 트래픽을 효과적으로 수용하기 위해 시행되는 정부 주관 사업

23) 파장 분할 다중화(WDN, Wavelength Division Multiplexing) -20.9 출제
광섬유를 이용한 통신 기술의 하나로, 파장이 서로 다른 복수의 신호를 보냄으로써 여러 대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 것.
파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성징을 이용한 기술

24) 소프트웨어 정의 데이터 센터(SDDC, Software Defined Data Center)
데이터센터의 모든 자원을 가상화하여 인력의 개입없이 소프트웨어 조작만으로 관리, 제어되는 데이터 센터를 의미
컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의함

25) 개방형 링크드 데이터(LOD, Linked Open Data)
Linked Data와 Open Data의 합성어, 누구나 사용할 수 있도록 웹상에 공개된 연계 데이터를 의미 
웹상에 존재하는 데이터를 개별 URI(인터넷 식별자)로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결 된 웹을 지향하는 모형

[18] 네트워크 설치 구축

1. 네트워크(Network)

- 두 대 이상의 컴퓨터를 전화선이나 케이블 등르로 연결하여 자원을 공유하는 것
- 다른 컴퓨터의 데이터, 프로그램, 주변장치, 인터넷등을 공유하기 위해 사용한다.
- 설치 구조 종류 : 성형, 링형, 버스형, 계층형 , 망형
- 지리적 범위에따라 LAN과 WAN 으로 분류된다.

1) 성형(Star, 중앙 집중형)
-성형은 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식 네트워크
- 포인트 투 포인트 방식으로 회선을 연결
- 각 단말장치들은 중앙 컴퓨터를 통하여 데이터 교환
- 단말장치의 추가와 제거 용이
- 하나의 단말장치가 고장나더라도 다른 단말장치에 영향을 주지 않음
- 중앙 컴퓨터가 고장나면 전체 통신망의 기능 정지
- 중앙 집중식이므로 교환 노드의 수가 적음

2) 링형(Ring , 루프형)
-컴퓨터와 단말장치들을 서로 이웃하는 것끼리 포인트 투 포인트방식으로 연결
- 분산 및 집중 제어 모두 가능
- 단말장치의 추가/제거 및 기밀 보호가 어려움
- 각 단말장치에서 전송 지연이 발생
- 중계기의 수가 많음
- 데이터는 단방향 또는 양방향으로 전송할 수 있다

3) 버스형(Bus)
- 버스형은 한 개의 통신 회선에 여러 대의 단말장치가 연결되어 있는 형태
- 단말장치의 추가와 제거 용이
- 단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성을 높일 수 있음
- 기밀 보장이 어렵고, 통신 회선의 길이에 제한 있음
- 통신 회선의 길이 제한이 있다.

4) 계층형(Tree, 분산형)
- 계층형은 중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고,
  이웃하는 단말장치는 일정 지역 내에 설치된 중간 단말장치로부터 다시 연결시키는 형태
- 분산 처리 시스템을 구성하는 방식

5) 망형(Mesh)
- 망형은 모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태로, 노드의 연결성이 높음
- 많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우 유리
- 통신 회선의 총 경로가 가장 긺
- 통신 회선 장애 시 다른 경로를 통해서 데이터 전송 가능
- 모든 노드를 망형으로 연결하려면 노드의 수가 n개일 때, n(n-1)/2개의 회선이 필요하고 노드당 n-1개의 포트가 필요 하다.

2. 네트워크의 분류

1) 근거리 통신망 (LAN Local Area Network) 

-회사, 학교, 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등과 같은 자원을 연결하여 구성한다. 
-주로 자원 공유를 목적으로 사용 
-사이트 간 거리가 짧아 데이터의 전송 속도가 빠르고 에러 발생률이 낮다 
-근거리 통신망에서는 주로 버스형이나 링형 구조를 사용한다 

2) 광대역 통신망 (WAN Wide Area Network) 

-국가와 국가 혹은 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성 
-사이트 간 거리가 멀기 때문에 통신 속도가 느리고 에러 발생률이 높다 
-일정한 지역에 있는 사이트들을 근거리 통신망으로 연결한 후 각 근거리 통신망을 연결하는 방식을 사용한다. 

3. LAN의 표준안
802.1	전체의 구성, OSI 7계층과의 관게, 통신망 관리 등에 관한 규약
802.2	논리 링크 제어(LLC) 계층에 관한 규약
802.3	CSMA/CD 방식의 매체 접근 제어 계층에 관한 규약
802.4	토큰 버스 바익의 매체 접근 제어 계층에 관한 규약
802.5	토큰 링 방식의 매체 접근 제어 계층에 관한 규약
802.6	도시형 통신망( MAN )에 관한 규약, 이중 버스로 구성된 DQDB에 관한 규야 
802.9      종합 음성/데이터 네트워크에 관한 규약
802.11	무선 LAN에 관한 규약
802.15	블루투스에 관한 규약

4. NAT(Network Address Translation, 네트워크 주소 변환)
- NAT은 한 개의 정식 IP 주소에 대향의 가상 사설 IP 주소를 할당 및 연결하는 기능이다.
- 한 개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 한 개로 제한되는 
문제가 있지만 IP 마스커레이드(리눅스NAT기능으로 리눅스 서버를 통해 다른 네트워크 접속 가능)를 이용하여 해결할 수 있다

[19] 스위치

1. 스위치 분류
- 스위치는 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 징치이다.
- 스위치는 OSI 7 계층의 Layer에 따라 L2, L3, L4, L7으로 분류된다.
1) L2스위치 : OSI 2계층의 속함 MAC 주소를 기반으로 프레임을 전송함, 동일 네트워크 연결만 가능
2) L3스위치 : OSI 3계층의 속함 L2에서 라우터 추가로, IP 주소를 기반으로 패킷 전송, 서로 다른 네트워크 연결 가능
3) L4스위치 : OSI 4계층에 속함 로드밸런서가 달린 L3 스위치로, IP 주소 및 TCP//UPD를 기반으로 사용하는 사용자들의 요구르,ㄹ
   서버의 부하가 적은 곳에 배분하는 로드밸런싱 기능 제공 *로드밸런서: 특정서버에만 부하가 발생하지 않도록 트래픽 분산장치
4) L7스위치 : OSI 7계층에 속함 IP주소, TCP/UDP 포트 정보에 패킷 내용까지 참조하여 세밀하게 로드밸런싱함

2. 스위칭 방식
1) Store and Forwarding : 데이터를 모두 받은 후 스위칭하는 방식
2) Cut-through : 데이터의 목적지 주소만을 확인한 후 바로 스위칭 하는 방식
3) Fragment Free : 위 두개의 장점을 결헙한 방식

3. 백본 스위치
- 네트워크들을 연결할때 중심 역할을 하는 네트워크를 백본(Backbone)이라 하고, 백본에서 스위칭 역할을 하는 장비를 백본 스위치라고 한다.
- 백본 스위치는 모든 패킷이 지나가는 네트워크의 중심에 배치한다.
- 대규모 트래픽을 처리하려면 고성능의 백본 스위치를 사용해야 한다.
- 주로 L3 스위치가 백본 스위치 역할을 한다.

4. Hierachical 3 Layer 모델
- 네트워크 구성 시 사용되는 모델의 한 종류로, 액세스 계층, 디스트리뷰션 계층, 코어 계층으로 분류
1) 액세스 계층(Access Layer)
사용자가 네트워크에 접속 할 때 최초로 연결되는 지점으로, 사용자들로부터 오는 통신을 집약해서 디스트리뷰션 계층으로 전송
성능은 낮아도 되지만 포트는 사용자 수만큼 있어야 함. L2 스위치 사용
2) 디스트리뷰션 계층(Distribution Layer)
액세스 계층의 장치들이 연결되는 지점이며, 액세스 계층에서 오는 통신을 집약해서 코어 계층으로 전송
LAN 간의 라우팅 기능 수행. 라우터, L3 스위치 사용
3) 코어 계층(Core Layer)(= 백본 계층)
디스트리뷰션 계층에서 오는 통신을 집약해 인터넷에 연결하는 계층
전자우편, 인터넷 접속, 화상 회의 등의 기능 수행. 백본 스위치 사용

[20] 경로 제어 / 트래픽 제어

1. 경로 제어(Routing)

- 전송 경로 중에서 최적 패킷 교환 경로를 결정하는 기능
- 경로제어표(Routing Table)을 참조하며, 라우터에 의해 수행
-경로 제어 요소
1) 성능 기준
2) 경로의 결정 시간과 장소
3) 정보 발생지
4) 경로 정보의 갱신 시간

2. 경로 제어 프로토콜(Routing Protocol)

- IGP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜)  
1) 하나의 자율 시스템(AS) 내의 라우팅에 사용되는 프로토콜

2) RIP(Routing Information Protocol)
- 현재 가장 널리 사용되는 프로토콜로 거리 벡터 라우팅 프로토콜로도 불리며, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용된다.
거리 벡터 라우팅 프로토콜이라고도 불리며 최단경로 탐색에 벨만포트(Bellman-Ford) 알고리즘 사용
- 소규모 동종의 네트워크(AS) 내에서 효율적인 방법
-최대 홉(Hop) 수를 15로 제한하므로 대규모 네트워크에서는 RIP 사용 불가 *홉 : 데이터가 목적지까지 거치는 네트워크 수
- 라우팅 정보를 30초마다 네트워크 내의 모든 라우터에 알리며, 180초 이내 새로운 라우팅 정보가 수신되지 않으면 해당경로를 이상으로 간주함


3) OSPF(Open Shortest Path First protocol)
- 대규모 네트워크에서 많이 사용되며, 경로 탐색 시 다익스트라(Dijkstra) 알고리즘 사용
- 노드간 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로 라우팅 지원
- 라우팅 정보에 변화가 생기는 경우 변화된 정보만 네트워크 내의 모든 라우터에 알림
- 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달함

4)EGP(Exterior Gateway Protocol) : 자율 시스템(AS) 간의 라우팅, 즉 게이트웨이 간의 라우팅에 사용되는 프로토콜

5)BGP(Border Gateway Protocol) : 초기에 BGP 라우터들이 연결될 때는 전체 라우팅테이블을 교환하고 이후에는 변화된 정보만 교환 

3. 트래픽 제어(Traffic Control)

- 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능
- 종류 : 흐름 제어, 폭주(혼합) 제어, 교착상태 방지

4. 흐름 제어(Flow Control)

- 네트워크 내의 원활한 흐름을 위한 송수신측 사이의 패킷의 양이나 속도를 규제하는 기능
1) 정지 대기(Stop and Wait) 
0 수신 측 확인 신호(ACK)를 받은 후 다음 패킷을 전송하며 한 번에 하나씩 전송 가능한 방식
2) 슬라이딩 윈도우(Sliding Window) 
0 수신 통지를 이용한 송신데이터의 양을 조절하는 방식으로 한 번에 여러개씩 전송 가능한 방식
0 송신 측은 수신 측으로부터 확인 신호(ACK) 없이도 보낼 수 있는 패킷의 최대치를 미리 약속받는데, 이 크기가 윈도우 크기를 의미
0 수신측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답이 전달된 경우 윈도우 크기 증가하고 부정 수신인경우 감소

5. 폭주 제어(Congestion Control)

-네트워크 내의 패킷 수를 조절해 네트워크의 오버플로(Overflow)를 방지하는 기능	
1) 느린 시작(Slow Start) 
0 윈도우의 크기를 1부터 2배씩 지수적으로 증가시켜 점진적으로 속도가 증가하며, 전송 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어감
2) 혼잡 회피(Congestion Avoidance)	
0 느린 시작의 지수적 증가가 임계 값에 도달하면 혼잡으로 간주하고 윈도우의 크기를 1씻 선형적으로 증가시켜 혼잡을 예방하는 방식

[21] SW관련 신기술

1. 인공지능(AI; Artificial Intelligence)
- 인공지능(AI)은 인간의 두뇌와 같이 컴퓨터 스스로 추론, 학습, 판단 등 인간지능적인 작업을 수행하는 시스템이다.
 
2. 뉴럴링크(Neuralink)
- 일론머스크가 사람의 뇌와 컴퓨터를 결합하는 기술을 개발하기 위해 설립한 회사
- 신경레이스(Neural Lace)기술 개발중으로, 작은 전극을 뇌에 이식함으로써 생각을 업로드/다운하는것을 목표로함
 
3. 딥 러닝(Deep Learning)
- 딥 러닝은 인간의 두뇌를 모델로 만들어진 인공 신경망(ANN; Artiifcial Neural Network)을 기반으로 하는 기계 학습 기술이다.

4. 전문가 시스템(Expert System)
- 의료 진단 등과 같은 특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 컴퓨터 응용 프로그램

5. 증강 현실(AR; Augmented Reality)
- 실제 촬영한 화면에 가상의 정보를 부가하여 보여주는 기술로, 혼합현실(MR; Mixed Reality)이라고도 부른다.

6. 블록체인(Blockchain)
- 블록체인은 P2P(Peer-to-Peer) 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술이다.

7. 분산 원장 기술(DLT; Distrubuted Ledger Technology)
- 중앙 관리자나 중앙 데이터 저장소가 존재하지 않고 P2P 망내의 참여자들에게 
  모든 거래 목록이 분산 저장되어 거래가 발생할 때마다 지속적으로 갱신되는 디지털 원장을 의미한다.

8. 해시(Hash)
- 해시는 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 말한다.

9. 양자 암호키 분배(QKD; Quantum Key Distribution)
- 양자 통신을 위해 비밀키를 분배하여 관리하는 기술
- 두 시스템이 암호 알고리즘 동작을 위한 비밀키를 안전하게 공유하기 위해 양자 암호키 분배 시스템을 설치하여 운영하는 방식으로 활용된다.

10. 프라이버시 강화 기술(PET; Privacy Enhancing Technology)
- 개인정보 침해 위험 관리 기술

11. 디지털 저작권 관리(DRM; Digital Rights Management)
- 인터넷이나 기타 디지털 매체를 통해 유통되는 데이터의 저작권을 보호를 위해 데이터의 안전한 배포를 활성화하거나 불법 배포를 방지하기 위한 시스템이다.

12. 공통 평가 기준(CC; Common Criteria)
- 1999년 ISO 15408 표준으로 채택된 정보 보호 제품 평가 기준이다.
- 정보화 순기능 역할을 보장하기 위해 정보화 제품의 정보 보호 기능과 이에 대한 사용 환경 등급을 정한 기중

13. 개인정보 영향평가 제도(PIA; Privacy Impact Assessment)
- 개인 정보를 활용하는 새로운 정보시스템의 도입 및 기존 정보시스템의 중요한 변경 시 시스템의 구축, 운영이 
   기업의 고객은 물론 국민의 사생활에 미칠 영향에 대해 미리 조사, 분석, 평가하는 제도이다.
- 개인정보보호법에 의해 공공기관은 의무화되어 있다.

14. 그레이웨어(Grayware)
- 소프트웨어를 제공하는 입장에서는 악의적이지 않은 유용한 소프트웨어라고 주장할 수 있지만 사용자 입장에서는 
  유용할 수도 있고 악의적일 수도 있는 애드웨어(광고를 댓가로 무료이용), 트랙웨어, 기타 악성 코드나 악성 공유웨어를 말한다.

15. 매시업(Mashup)
- 매시업은 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술이다. 
  즉 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹 사이트 또는 웹 애플리케이션을 말한다.
- 구글 지도에 부동산 매물 정보를 결합한 구글의 하우징맵스(HousingMaps)가 대표적인 메시업이다.

16. 리치 인터넷 애플리케이션(RIA; Rich Internet Application)
- 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML 보다 역동적이고 인터랙티브한 웹페이지를 제공하는 
  신개념의 플래시 웹페이지 제작 기술이다.

17. 시맨틱 웹(Semantic Web)
- 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹이다.

18. 증발품(Vaporware)
- 판매 계획 또는 배포 계획은 발표되었으나 실제로 고객에게 판매되거나 배포되지 않고 있는 소프트웨어

19. 오픈 그리드 서비스 아키텍처(OGSA; Open Grid Service Architecture)
- 애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공하기 위해 만든 개방형 표준이다.

20. 서비스 지향 아키텍처(SOA; Service Oriented Architecture)
- 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처이다.
- SOA 기반 애플리케이셔 구성 계층(표현계층,업무 프로세스계층, 서비스 중간 계층, 애플리케이션 계층, 데이터 저장 계층)
 
21. 서비스형 소프트웨어(SaaS; Software as a Service)
- 소프트웨어의 여러 기능 중에서 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 소프트웨어이다.

22. 소프트웨어 에스크로(임치)(Software Escrow)
- 소프트웨어 개발자의 지식재산권을 보호하고 사용자는 저렴한 비용으로 소프트웨어를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술 정보 등을 제3의 기관에 보관하는 것이다.

23. 복잡 이벤트 처리(CEP; Complex Event Processing)
- 실시간으로 발생하는 많은 사건들 중 의미가 있는 것만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법이다.

24. 디지털 트윈(Digital Twin)
- 현실속의 사물을 소프트웨어로 가상화한 모델로, 자동차, 항공 등 여라 분야에서 주목 받고 있다.
- 실제 물리적인 자산을 소프트웨어로 가상화함으로써 실제 자신의 특성에 대한 정확한 정보를 얻을 수 있음

[22] 소프트웨어 개발 직무별 보안 활동

1. 소프트웨어 개발 직무별 보안 활동
- 안전한 소프트웨어 개발을 위해서는 프로젝트 관련자들이 보안 활동을 수행할 수 있도록 각 직무별로 수행해야 할 보안 활동을 정의해야 한다.
- 소프트웨어 개발 참여자의 직무는 프로젝트 관리자, 요구사항 분석가, 아키텍트, 설계자, 구현 개발자, 테스트 분석가, 보안 감사자로 구분한다.

2. 프로젝트 관리자(Project Manager)
- 응용 프로그램에 대한 보안 전략을 조직 구성원들에게 전달한다.
- 조직 구성원들에게 응용 프로그램 보안 영향을 이해시킨다.
- 조직의 상태를 모니터링 한다.

3. 요구사항 분석가(Requirement Specifier)
- 아키텍트가 고려해야 할 보안 관련 비즈니스 요구사항을 설명한다.
- 프로젝트 팀이 고려해야 할 구조 정의 및 해당 구조에 존재하는 자원에 대한 보안 요구사항을 정의한다.

4. 아키텍트(Architect)
- 보안 오류가 발생하지 않도록 보안 기술 문제를 충분히 이해한다.
- 시스템에 사용되는 모든 리소스 정의 및 각 리소스별로 적절한 보안 요구사항을 적용한다.

5. 설계자(Designer)
- 특정 기술에 대해 보안 요구사항의 만족성 여부를 확인한다.
- 문제 발생 시 최선의 문제 해결 방법을 결정한다.
- 애플리케이션 보안 수준에 대한 품질 측정을 지원한다.
- 많은 비용이 필요한 수정 요구사항을 최소화하기 위한 방법을 제공한다.
- 다른 소프트웨어와 통합할 때 발생할 수 있는 보안 위험에 대해 이해해야 한다.
- 소프트웨어에서 발견된 보안 위협에 대해 적절히 대응한다.

6. 구현 개발자(Implementer)
- 구조화된 소프트웨어 개발 환경에서 프로그램을 원활히 구현할 수 있도록 시큐어 코딩 표준을 준수하여 개발한다.
- 다른 사람이 소프트웨어의 안전 여부를 쉽게 확인할 수 있도록 문서화 한다.

7. 테스트 분석가(Test Analyst)
- 소프트웨어 개발 요구사항과 구현 결과를 반복적으로 확인한다.
- 테스트 분석가는 반드시 보안 전문가일 필요는 없지만 보안 위험에 대한 학습이나 툴(Tool) 사용법 정도는 숙지하고 있어야 한다.

8. 보안 감시자(Security Auditor)
- 소프트웨어 개발 프로젝트의 현재 상태의 보안을 보장한다.
- 요구사항 검토 시 요구사항의 적합성과 완전성을 확인한다.
- 소프트웨어 개발 프로젝트의 전체 단계에서 활동한다.
- 설계 단계에서는 보안 문제로 이어질 수 있는 사항이 있는지 확인한다.
- 구현 단계에서는 보안 문제가 있는지 확인한다.

[23] 소프트웨어 개발 보안 활동 관련 법령 및 규정

1. 개인정보 보호 관련 법령
- 개인정보 보호법 : 개인정보의 처리 및 보호에 관한 사항을 정함으로써 개인의 자유와 권리를 보호한다.
- 정보통신망 이용촉진 및 정보보호 등에 관한 법률 : 정보통신망의 이용 촉진 및 정보 통신 서비스를 이용하는 이용자들의 개인정보를 보호한다.
- 신용정보의 이용 및 보호에 관한 법률 : 개인 신용정보의 효율적 이용과 체계적인 관리를 통해 정보의 오남용을 방지한다.
- 위치정보의 보호 및 이용 등에 관한 법률 : 개인 위치정보의 효율적 이용과 체계적인 관리를 통해 정보의 오남용을 방지한다.
- 표준 개인정보 보호 지침 : 개인정보의 처리에 관한 기준, 개인정보 침해의 유형 및 예방조치 등에 관한 세부사항을 규정한다.
- 개인정보의 안전성 확보 조치 기준 : 개인정보 처리자가 개인정보를 처리하는데 있어 개인정보가 분실, 도난, 유출, 위조, 변조, 훼손되지 않도록 
   안전성 확보에 필요한 기술적, 관리적, 물리적 안전조치에 관한 최소한의 기준을 규정한다.
- 개인정보 영향평가에 관한 고시 : 개인정보 영향평가를 위한 평가기관의 지정, 영향평가의 절차 등에 관한 세부기준을 규정한다.

2. IT 기술 관련 규정
- RFID 프라이버시 보호 가이드라인 : RFID 시스템의 이용자들의 프라이버시를 보호
- 위치정보의 보호 및 이용 등에 관한 법률 : 개인 위치정보의 유출 및 오남용을 방지하기 위한 법률
- 위치정보의 관리적, 기술적 보호조치 권고 해설서 : 개인 위치정보의 누출, 변조 훼손 등을 방지하기 위해 위치정보 사업자 및 위치기반 서비스 사업자가 준수해야 하는 관리적, 기술적 보호조치의 구체적인 기준
- 바이오정보 보호 가이드라인 : 개인 바이오정보(지문, 홍채, 음성 등)의 보호와 안전한 활용을 위한 원칙 및 조치사항
- 뉴미디어 서비스 개인정보 보호 가이드라인 : 뉴미디어 서비스(클라우드, SNS 등) 이용 및 제공 시 개인정보의 침해사고를 예방하기 위한 준수사항

[24] HW 관련 신기술

1. 고가용성(HA; High Availability)
- 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘을 의미한다.

2. 3D Printing(Three Dimension Printing)
- 대상을 평면으로 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어내는 것

3. 4D Printing(Fourth Dimension Printing)
- 특정 시간이나 환경 조건이 갖춰지면 스스로 형태를 변화시키거나 제조되는 자가 조립 기술이 적용된 제품을 3D Printing하는 기술

4. RAID
- 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우 
  그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 RAID라고 한다.

5. 4K 해상도
- 3840x2160 이며, FULL HDTV(1920x180)에 비해 총 4배에 해당하는 차세대 고화질 모니터의 해상도를 지칭하는 용어

6. 앤 스크린(N-Screen)
- N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스

7. 컴패니언 스크린(Companion Screen)
- 컴패니언 스크린은 앤 스크린의 한 종류로, TV 방송 시청 시 방송 내용을 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태블릿 PC 등을 의미한다. 세컨드 스크린(Second Screen)이라고도 불린다.

8. 신 클라이언트 PC(Thin Client PC)
- 하드디스크나 주변 장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터를 말하는 것으로, 서버 기반 컴퓨팅과 관계가 깊다.

 9. 패블릿(Phablet)
- 폰과 태블릿의 합성어로, 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰을 말한다.

10. C형 유에스비
- 범용 인터페이스 규격인 유에스비의 표준 중 하나, 전력 전송량이 증대됨에 따라 전원 케이블을 필요로 하던 주변기기들을 C형 유에스비만으로 연결할 수 있게 되면서 기기 간 연결의 편의성이 증대되었다.

11. 멤스(MEMS; Micro-Electro Mechanical Systems)
- 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터(Actuator) 등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치이다.

12. 트러스트존 기술(TrustZone Technology)
- 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안 기술

 13. 엠디스크(M-DISC)
- 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장 장치이며, 디스크 표면의 무기물층에 레이저를 이용해 자료를 기록한다.
- 디지털 비디오 디스크(DVD)와 블루레이 디스크(Blue-ray Dist)에 적용된다.
- 빛, 열, 습기 등 외부 영향을 받지 않음
 
14. 멤리스터(Memristor)
- 멤리스터는 메모리와 레지스터의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자이다.
- 레지스터, 커패시터, 인덕터에 이어 네 번째 전자회로 구성요소라 불리고 있다.

[25] Secure OS

1. Secure OS
- 기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제를 의미
- 보안 커널은 보안 기능을 갖춘 커널을 의미하며, TCB(Trusted Computing Base)를 기반으로 참조 모니터의 개념을 구현하고 집행한다.
- 보안 커널의 보호 대상에는 메모리와 보조기억장치, 그리고 그곳에 저장된 데이터, 하드웨어 장치, 자료 구조 등이 있다.
- 보호 방법을 구현하기 복잡한 것부터 차례대로 분류하면 다음과 같다.
0 암호적 분리(Cryptographic Separation) : 내부 정보를 암호화하는 방법
0 논리적 분리(Logical Separation) : 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법
0 시간적 분리(Temporal Separation) : 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법
0 물리적 분리(Physical Separation) : 사용자별로 특정 장비만 사용하도록 제한하는 방법

2. Secure OS의 보안 기능
- Secure OS의 보안 기능에는 식별 및 인증, 임의적/강제적 접근 통제, 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소 등이 있다.
- 식별 및 인증 : 각 접근 주체에 대한 안전하고 고유한 식별 및 인증 기능
- 임의적 접근통제 : 소속 그룹 또는 개인에 따라 부여된 권한에 따라 접근을 통제하는 기능
- 강제적 접근통제 : 규칙에 따라 강제적으로 접근을 통제하는 기능
- 객체 재사용 보호 : 메모리에 기존 데이터가 남아있지 않도록 초기화하는 기능
- 완전한 조정 : 우회할 수 없도록 모든 접근 경로를 완전하게 통제하는 기능
- 신뢰 경로 : 비밀번호 변경 및 권한 설정 등과 같은 보안 작업을 위한 안전한 경로 제공
- 감사 및 감사기록 축소 : 모든 보안 관련 사건 및 작업을 기록(Log)한 후 보호하는 기능

3. 참조 모니터(Reference Monitor)
- 보호대상의 객체에 대한 접근통제를 수행하는 추상머신이며, 이것을 실제로 구현한 것이 보안 커널이다.
- 보안 커널 데이터베이스(SKDB)를 참조하여 객체에 대한 접근 허가 여부를 결정한다.
- 참조 모니터와 보안 커널은 다음 3가지 특징을 가진다.
0 격리성(Isolation) : 부정 조작이 불가능해야 한다.
0 검증가능성(Verifiability) : 적절히 구현되었다는 것을 확인할 수 있어야 한다.
0 완전성(Completeness) : 우회가 불가능해야 한다.

[26] DB 관련 신기술

1. 빅데이터(Big Data)
- 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합
- 기업이나 정부, 포털 등이 빅데이터를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고 새로운 가치를 창출한다.

2. 브로드 데이터(Broad Data)
- 다양한 채널에서 소비자와 상호 작용을 통해 생성된, 기업 마케팅에 있어 효율적이고 다양한 데이터이며 이전에 사용하지 않거나 알지 못했던 새로운 데이터나, 기존 데이터에 새로운 가치가 더해진 데이터
- 빅데이터와는 달리 다양한 정보를 뜻하는 것으로, 소비자의 SNS활동이나 위치 정보 등이 이에 속한다.

3. 메타 데이터(Meta Data)
- 일련의 데이터를 정의하고 설명해 주는 데이터이다. 컴퓨터에서는 데이터 사전의 내용, 스키마 등을 의미하고, HTML 문서에서는 메타 태그 내의 내용이 메타 데이터이다.
- 여러 용도로 사용되나 주로 빠르게 검색하거나 내용을 간략하고 체계적으로 하기 위해 많이 사용된다.

4. 디지털 아카이빙(Digital Archiving)
- 디지털 아카이빙은 디지털 정보 자원을 장기적으로 보존하기 위한 작업을 말한다. 
- 아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업이다.

5. 하둡(Hadoop)
- 하둡은 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼이다.
- 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크로, 구글, 야후 등에 적용되고 있다.

 6. 타조(Tajo)
- 타조는 오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트로, 우리나라가 주도하여 개발하고 있다. 
- 타조는 하둡의 빅데이터를 분석할 때 맵리듀스(MapReduce)를 사용하지 않고 구조화 질의 언어(SQL)을 사용하여 하둡 분산 파일 시스템(HDFS; Hadoop Distrubuted File System) 파일을 바로 읽어낼 수 있다.
- 타조는 대규모 데이터 처리와 실시간 상호 분석에 모두 사용할 수 있다.

7. 데이터 다이어트(Data Diet)
- 데이터 다이어트는 데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 작업이다.

8. 데이터 마이닝 (Data Mining)
- 대량의 데이터를 분석하여 데이터내에 내재된 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법

9. OLAP(Online Analyticla Processing) 
- 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식
- OLAP 연산 : Roll-up, Drill-down, Drill-through, Drill-across, Pivoting, Slicing, Dicing

[27] 회복 / 병행제어

1. 회복(Recovery)
- 회복은 트랜잭션을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업이다.
- 회복기법의 종류
1) 연기 갱신 기법 (Deferred Update)
- 트랙잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법
- 트랙잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨
- 트랙잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함
- Redo 작업만 가능함
* 재시도(Redo) : 덤프와 로그를 이용하여 가장 최근의 정상데이터베이스로 회복시킨 후 트랙잭션 재실행
* 취소(Undo) : 로그에 보관한 정보를 이용하여 가장 최근에 변경된 내용부터 거슬러 올라가면서 트랜잭션 작업을 취소하여 원래의 데이터로 돌아감

2) 즉각 갱신 기법 (Immediate Update)
 - 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법이다.
 - 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킨다.
 - 회복 작업을 할 경우에는 Redo와 Undo 모두 사용이 가능하다.

3) 그림자 페이지 대체기법 (Shadow Paging)
 - 그림자 페이지 대체 기법은 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지로 별도 보관해 놓고, 
   실제 페이지를 대상으로 트랜잭션에 의한 갱신 작업을 하다가 장애가 발생하여 트랜잭션 작업을 Rollback시킬 때, 갱신된 이후의 실제 페이지 부분에 
   그림자 페이지를 대체하여 회복시키는 기법이다.

4) 검사적 기법 (Check Point)
-  검사점 기법은 트랜잭션 실행 중 특정 단계에서 재 실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 
   장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을  하여 회복시간을 절야하도록 하는 기법이다.

2. 병행제어(Concurrency Control)
- 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것이다.
- 병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제가 발생한다.
0 갱신 분실(Lost Update) : 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상
0 비완료 의존성(Uncommitted Dependency) : 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상. 임시 갱신이라고도 한다.
0 모순성(Inconsistency) : 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제. 불일치 분석이라고도 한다.
0 연쇄 복귀(Cascading Rollback) : 병행수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상
- 병행제어 기법의 종류
1) 로킹(Locking)
- 로킹은 주요 데이터의 액세스를 상호 배타적으로 하는 것이다.
- 트랜잭션들이 어떤 로킹 단위를 액세스 하기 전에 Lock을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법이다.

2) 타임 스탬프 순서(Time Stamp Ordering)
- 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 작업을 수행하는 기법이다.
- 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법이다.
- 교착상태가 발생하지 않는다.

3) 최적 병행 수행(검증 기법, 확인 기법, 낙관적 기법)
- 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 
  실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법이다.

4) 다중 버전 기법
- 타임 스탬프의 개념을 이용하는 기법으로, 다중 버전 타임 스탬프 기법이라고도 한다.
- 타임 스탬프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 부여하여 관리한다.

3. 로킹 단위 (Locking Granularity)

- 로킹 단위는 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미한다.
- 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있다.
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다
- 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하집만 병행성 수준이 높아진다.

[28] 교착상태

1. 교착상태 (Dead Lock)
- 상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 자원을 요구하며 무한정 기다리는 현상을 말한다.

2. 교착상태 발생의 필요 충분 조건
- 아래의 네가지 조건이 모두 충족되어야 교착상태가 발생합니다. 교착상태는 프로세스 뿐만 아니라 스레드 또한 발생할 수 있습니다.
1) 상호배제 (Mutual Exclusion) 
- 한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야한다
2) 점유와 대기 (Hold and Wait)
- 최소한 하나의 자원을 점유하고 있으며 다른 프로세스가 점유하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야한다
3) 비선점 (Non-preemption)
- 다른 프로세스가 점유한 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없어야한다
4) 환형 대기 (Circular Wait)
- 자원을 점유하며 다른 프로세스가 점유하고 있는 자원을 사용하기 위해 대기하는 프로세스(점유가 대기 중인 프로세스)들이 
  원형으로 자신의 앞 또는 뒤에 있는 프로세스가 점유한 자원을 요청해야합니다.

3. 교착상태의 해결 방법

1) 예방 기법 (Prevention)
- 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 기법
- 교착상태 발생 네가지 조건중 하나를 제거
- 자원의 낭비가 가장 심한 기법임

2) 회피 기법 (Avoidance)
- 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법
- 주로 은행원 알고리즘(Banker's Algoritm)이 사용됨
- 은행원 알고리즘 : 다익스트라가 제안한것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법

3) 발견 기법 (Detection)
- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것
- 교착상태 발견 알고리즘과 자원 할당 그래프 등을 이용 할 수 있음

4) 회복 기법 (Recovery)
- 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

178. 데이터 표준화

1. 데이터 표준화의 정의
- 데이터 표준화는 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것을 의미한다.
- 데이터 표준화 작업을 통해 사용자가 데이터를 정확히 이해하고 활용할 수 있도록 항목명이 부여된다.
- 엔티티, 속성, 테이블, 컬럼 등 데이터 요소에서 사용되는 단어에 대해 일정한 규칙이 적용된다.

2. 데이터 표준 구성 요소

1) 데이터 표준
- 데이터 표준은 데이터 모델이나 DB에서 정의할 수 있는 모든 오브젝트를 대상으로 데이터 표준화를 수행해야 한다.
- 표준 단어 : 업무에서 사용하고 일정한 의미를 갖고 있는 최소 단위의 단어를 의미한다.
- 표준 데이터 : 문자형, 숫자형, 날짜형, 시간형과 같이 컬럼을 성질에 따라 그룹핑한 개념
- 표준 코드 : 선택할 수 있는 값을 정형화하기 위해 기준에 맞게 이미 정의된 코드 값으로, 도메인의 한 유형이다.
- 표준 용어 : 단어, 도메인, 코드 표준이 정의되면 이를 바탕으로 표준 용어를 구성한다.

2) 데이터 관리 조직
- 데이터 관리 조직은 데이터 표준 원칙이나 데이터 표준의 준수 여부 등을 관리하는 사람들로, 대표적으로 데이터 관리자가 있다.
- 데이터 관리자는 조직 내의 데이터에 대한 정의, 체계화, 감독 등의 업무를 담당한다.
 
3) 데이터 표준화 절차
- 데이터 표준화 요구사항 수집, 데이터 표준 정의, 데이터 표준 확정, 데이터 표준 관리 순으로 진행된다.

3. 데이터 표준화의 대상

-데이터 명칭 : 데이터를 유일하게 구별할 수 있는 유일성, 의미 전달 충분성, 업무적 보편성을 갖는 이름으로 정의
-데이터 정의 : 데이터를 제3자 입장에서도 쉽게 이해할 수 있도록 데이터가 의미하는 범위 및 자격 요건 등을 규정
-데이터 형식 : 업무 규칙 및 사용 목적과 유사한 데이터에 대해 일관되게 데이터 형식을 정의함으로써 데이터 입력 오류, 통제 위험 등을 최소화
-테이터 규칙 : 기본 값, 허용 값, 허용 범위 등과 같이 발생할 수 있는 데이터 값을 사전에 지정함으로써 데이터의 정합성 및 완정성을 향상
